/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/css-loader/dist/cjs.js!./src/index.css":
/*!*************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/index.css ***!
  \*************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/noSourceMaps.js */ \"./node_modules/css-loader/dist/runtime/noSourceMaps.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `* {\r\n    color: white;\r\n    box-sizing: border-box;\r\n}\r\n\r\nbody {\r\n    background-color: black;\r\n    margin: 0;\r\n    padding: 0;\r\n    display: flex;\r\n    min-height: 100vh;\r\n}\r\n\r\n.gameDivision,\r\n.chatDivision,\r\n.utilDivision {\r\n    border: 1px solid white;\r\n    text-align: center;\r\n    height: 100vh;\r\n}\r\n\r\n.chatDivision,\r\n.utilDivision {\r\n    flex: 1 1 10dvw;\r\n}\r\n\r\n.gameDivision {\r\n    flex: 2.5 2.5 auto;\r\n    display: flex;\r\n    flex-direction: column;\r\n}\r\n\r\n.gameDivision .topBar,\r\n.gameDivision .midBar,\r\n.gameDivision .botBar {\r\n    border: 1px solid white;\r\n}\r\n\r\n.gameDivision .topBar{\r\n    flex: 2 1 auto;\r\n}\r\n\r\n.gameDivision .midBar{\r\n    flex: 90 1 10dvh;\r\n    display: flex;\r\n    flex-direction: column;\r\n}\r\n\r\n.gameDivision .botBar{\r\n    flex: 10 1 auto;\r\n}\r\n\r\n.NPCBar {\r\n    border: 1px solid white;\r\n    flex: 1 1 auto;\r\n    flex-direction: column;\r\n    display: flex;\r\n    justify-content: space-around;\r\n    align-items: center;\r\n}\r\n\r\n.PCBar {\r\n    border: 1px solid white;\r\n    flex: 1 1 auto;\r\n    display: flex;\r\n    flex-direction: column;\r\n    justify-content: space-around;\r\n    align-items: center;\r\n}\r\n\r\n.NPC {\r\n    border: 1px solid white;\r\n    width: 125px;\r\n    height: 125px;\r\n}\r\n\r\n.PC {\r\n    border: 1px solid white;\r\n    width: 125px;\r\n    height: 125px;\r\n}\r\n\r\n.ability {\r\n    border: 1px solid white;\r\n    flex: 1 1 auto;\r\n}\r\n\r\n.slideLeft,\r\n.slideRight {\r\n    border: 1px solid white;\r\n    flex: .025 1 auto;\r\n}\r\n\r\n.botBar {\r\n    display: flex;\r\n    justify-content: space-evenly;\r\n}\r\n\r\n.abilityListContainer {\r\n    display: flex;\r\n    flex: 1 1 auto;\r\n}\r\n\r\n.utilDivision {\r\n    display: flex;\r\n    flex-direction: column;\r\n    justify-content: space-between;\r\n}\r\n\r\n.endTurnButton {\r\n    border: 1px solid white;\r\n    flex: .09 1 auto;\r\n    text-align: center;\r\n    display: flex;\r\n    justify-content: center;\r\n    align-items: center;\r\n}\r\n\r\n.topBar {\r\n    display: flex;\r\n    justify-content: space-betweens;\r\n}\r\n\r\n.topBar div {\r\n    flex: 1 1 auto;\r\n}\r\n\r\n.PCBarRow1, \r\n.PCBarRow2, \r\n.PCBarRow3,\r\n.NPCBarRow1,\r\n.NPCBarRow2,\r\n.NPCBarRow3\r\n {\r\n    align-items: center;\r\n    justify-content: space-around;\r\n    display: flex;\r\n    width: 100%;\r\n    flex: 1 1 125px;\r\n    border: 1px solid white;\r\n}\r\n\r\n.divider {\r\n    padding: 15px;\r\n}\r\n\r\n.chatDivision {\r\n    display: flex;\r\n    flex-direction: column;\r\n    justify-content: space-between;\r\n}\r\n\r\n.moveRowButtons {\r\n    border: 1px solid white;\r\n    flex: .09 1 auto;\r\n    text-align: center;\r\n    display: flex;\r\n    justify-content: center;\r\n    align-items: center;\r\n}\r\n\r\n.moveRowButtons div{\r\n    border: 1px solid white;\r\n    flex: 1 1 auto;\r\n    height: 100%;\r\n    display: flex;\r\n    justify-content: center;\r\n    align-items: center;\r\n}`, \"\"]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack:///./src/index.css?./node_modules/css-loader/dist/cjs.js");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("\r\n\r\n/*\r\n  MIT License http://www.opensource.org/licenses/mit-license.php\r\n  Author Tobias Koppers @sokra\r\n*/\r\nmodule.exports = function (cssWithMappingToString) {\r\n  var list = [];\r\n\r\n  // return the list of modules as css string\r\n  list.toString = function toString() {\r\n    return this.map(function (item) {\r\n      var content = \"\";\r\n      var needLayer = typeof item[5] !== \"undefined\";\r\n      if (item[4]) {\r\n        content += \"@supports (\".concat(item[4], \") {\");\r\n      }\r\n      if (item[2]) {\r\n        content += \"@media \".concat(item[2], \" {\");\r\n      }\r\n      if (needLayer) {\r\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\r\n      }\r\n      content += cssWithMappingToString(item);\r\n      if (needLayer) {\r\n        content += \"}\";\r\n      }\r\n      if (item[2]) {\r\n        content += \"}\";\r\n      }\r\n      if (item[4]) {\r\n        content += \"}\";\r\n      }\r\n      return content;\r\n    }).join(\"\");\r\n  };\r\n\r\n  // import a list of modules into the list\r\n  list.i = function i(modules, media, dedupe, supports, layer) {\r\n    if (typeof modules === \"string\") {\r\n      modules = [[null, modules, undefined]];\r\n    }\r\n    var alreadyImportedModules = {};\r\n    if (dedupe) {\r\n      for (var k = 0; k < this.length; k++) {\r\n        var id = this[k][0];\r\n        if (id != null) {\r\n          alreadyImportedModules[id] = true;\r\n        }\r\n      }\r\n    }\r\n    for (var _k = 0; _k < modules.length; _k++) {\r\n      var item = [].concat(modules[_k]);\r\n      if (dedupe && alreadyImportedModules[item[0]]) {\r\n        continue;\r\n      }\r\n      if (typeof layer !== \"undefined\") {\r\n        if (typeof item[5] === \"undefined\") {\r\n          item[5] = layer;\r\n        } else {\r\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\r\n          item[5] = layer;\r\n        }\r\n      }\r\n      if (media) {\r\n        if (!item[2]) {\r\n          item[2] = media;\r\n        } else {\r\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\r\n          item[2] = media;\r\n        }\r\n      }\r\n      if (supports) {\r\n        if (!item[4]) {\r\n          item[4] = \"\".concat(supports);\r\n        } else {\r\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\r\n          item[4] = supports;\r\n        }\r\n      }\r\n      list.push(item);\r\n    }\r\n  };\r\n  return list;\r\n};\n\n//# sourceURL=webpack:///./node_modules/css-loader/dist/runtime/api.js?");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/noSourceMaps.js":
/*!**************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/noSourceMaps.js ***!
  \**************************************************************/
/***/ ((module) => {

eval("\r\n\r\nmodule.exports = function (i) {\r\n  return i[1];\r\n};\n\n//# sourceURL=webpack:///./node_modules/css-loader/dist/runtime/noSourceMaps.js?");

/***/ }),

/***/ "./src/index.css":
/*!***********************!*\
  !*** ./src/index.css ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleDomAPI.js */ \"./node_modules/style-loader/dist/runtime/styleDomAPI.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertBySelector.js */ \"./node_modules/style-loader/dist/runtime/insertBySelector.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ \"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertStyleElement.js */ \"./node_modules/style-loader/dist/runtime/insertStyleElement.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleTagTransform.js */ \"./node_modules/style-loader/dist/runtime/styleTagTransform.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../node_modules/css-loader/dist/cjs.js!./index.css */ \"./node_modules/css-loader/dist/cjs.js!./src/index.css\");\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());\noptions.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());\noptions.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, \"head\");\noptions.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"], options);\n\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"] && _node_modules_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals ? _node_modules_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals : undefined);\n\n\n//# sourceURL=webpack:///./src/index.css?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

eval("\r\n\r\nvar stylesInDOM = [];\r\nfunction getIndexByIdentifier(identifier) {\r\n  var result = -1;\r\n  for (var i = 0; i < stylesInDOM.length; i++) {\r\n    if (stylesInDOM[i].identifier === identifier) {\r\n      result = i;\r\n      break;\r\n    }\r\n  }\r\n  return result;\r\n}\r\nfunction modulesToDom(list, options) {\r\n  var idCountMap = {};\r\n  var identifiers = [];\r\n  for (var i = 0; i < list.length; i++) {\r\n    var item = list[i];\r\n    var id = options.base ? item[0] + options.base : item[0];\r\n    var count = idCountMap[id] || 0;\r\n    var identifier = \"\".concat(id, \" \").concat(count);\r\n    idCountMap[id] = count + 1;\r\n    var indexByIdentifier = getIndexByIdentifier(identifier);\r\n    var obj = {\r\n      css: item[1],\r\n      media: item[2],\r\n      sourceMap: item[3],\r\n      supports: item[4],\r\n      layer: item[5]\r\n    };\r\n    if (indexByIdentifier !== -1) {\r\n      stylesInDOM[indexByIdentifier].references++;\r\n      stylesInDOM[indexByIdentifier].updater(obj);\r\n    } else {\r\n      var updater = addElementStyle(obj, options);\r\n      options.byIndex = i;\r\n      stylesInDOM.splice(i, 0, {\r\n        identifier: identifier,\r\n        updater: updater,\r\n        references: 1\r\n      });\r\n    }\r\n    identifiers.push(identifier);\r\n  }\r\n  return identifiers;\r\n}\r\nfunction addElementStyle(obj, options) {\r\n  var api = options.domAPI(options);\r\n  api.update(obj);\r\n  var updater = function updater(newObj) {\r\n    if (newObj) {\r\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\r\n        return;\r\n      }\r\n      api.update(obj = newObj);\r\n    } else {\r\n      api.remove();\r\n    }\r\n  };\r\n  return updater;\r\n}\r\nmodule.exports = function (list, options) {\r\n  options = options || {};\r\n  list = list || [];\r\n  var lastIdentifiers = modulesToDom(list, options);\r\n  return function update(newList) {\r\n    newList = newList || [];\r\n    for (var i = 0; i < lastIdentifiers.length; i++) {\r\n      var identifier = lastIdentifiers[i];\r\n      var index = getIndexByIdentifier(identifier);\r\n      stylesInDOM[index].references--;\r\n    }\r\n    var newLastIdentifiers = modulesToDom(newList, options);\r\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\r\n      var _identifier = lastIdentifiers[_i];\r\n      var _index = getIndexByIdentifier(_identifier);\r\n      if (stylesInDOM[_index].references === 0) {\r\n        stylesInDOM[_index].updater();\r\n        stylesInDOM.splice(_index, 1);\r\n      }\r\n    }\r\n    lastIdentifiers = newLastIdentifiers;\r\n  };\r\n};\n\n//# sourceURL=webpack:///./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

eval("\r\n\r\nvar memo = {};\r\n\r\n/* istanbul ignore next  */\r\nfunction getTarget(target) {\r\n  if (typeof memo[target] === \"undefined\") {\r\n    var styleTarget = document.querySelector(target);\r\n\r\n    // Special case to return head of iframe instead of iframe itself\r\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\r\n      try {\r\n        // This will throw an exception if access to iframe is blocked\r\n        // due to cross-origin restrictions\r\n        styleTarget = styleTarget.contentDocument.head;\r\n      } catch (e) {\r\n        // istanbul ignore next\r\n        styleTarget = null;\r\n      }\r\n    }\r\n    memo[target] = styleTarget;\r\n  }\r\n  return memo[target];\r\n}\r\n\r\n/* istanbul ignore next  */\r\nfunction insertBySelector(insert, style) {\r\n  var target = getTarget(insert);\r\n  if (!target) {\r\n    throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\r\n  }\r\n  target.appendChild(style);\r\n}\r\nmodule.exports = insertBySelector;\n\n//# sourceURL=webpack:///./node_modules/style-loader/dist/runtime/insertBySelector.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

eval("\r\n\r\n/* istanbul ignore next  */\r\nfunction insertStyleElement(options) {\r\n  var element = document.createElement(\"style\");\r\n  options.setAttributes(element, options.attributes);\r\n  options.insert(element, options.options);\r\n  return element;\r\n}\r\nmodule.exports = insertStyleElement;\n\n//# sourceURL=webpack:///./node_modules/style-loader/dist/runtime/insertStyleElement.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\r\n\r\n/* istanbul ignore next  */\r\nfunction setAttributesWithoutAttributes(styleElement) {\r\n  var nonce =  true ? __webpack_require__.nc : 0;\r\n  if (nonce) {\r\n    styleElement.setAttribute(\"nonce\", nonce);\r\n  }\r\n}\r\nmodule.exports = setAttributesWithoutAttributes;\n\n//# sourceURL=webpack:///./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

eval("\r\n\r\n/* istanbul ignore next  */\r\nfunction apply(styleElement, options, obj) {\r\n  var css = \"\";\r\n  if (obj.supports) {\r\n    css += \"@supports (\".concat(obj.supports, \") {\");\r\n  }\r\n  if (obj.media) {\r\n    css += \"@media \".concat(obj.media, \" {\");\r\n  }\r\n  var needLayer = typeof obj.layer !== \"undefined\";\r\n  if (needLayer) {\r\n    css += \"@layer\".concat(obj.layer.length > 0 ? \" \".concat(obj.layer) : \"\", \" {\");\r\n  }\r\n  css += obj.css;\r\n  if (needLayer) {\r\n    css += \"}\";\r\n  }\r\n  if (obj.media) {\r\n    css += \"}\";\r\n  }\r\n  if (obj.supports) {\r\n    css += \"}\";\r\n  }\r\n  var sourceMap = obj.sourceMap;\r\n  if (sourceMap && typeof btoa !== \"undefined\") {\r\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\r\n  }\r\n\r\n  // For old IE\r\n  /* istanbul ignore if  */\r\n  options.styleTagTransform(css, styleElement, options.options);\r\n}\r\nfunction removeStyleElement(styleElement) {\r\n  // istanbul ignore if\r\n  if (styleElement.parentNode === null) {\r\n    return false;\r\n  }\r\n  styleElement.parentNode.removeChild(styleElement);\r\n}\r\n\r\n/* istanbul ignore next  */\r\nfunction domAPI(options) {\r\n  if (typeof document === \"undefined\") {\r\n    return {\r\n      update: function update() {},\r\n      remove: function remove() {}\r\n    };\r\n  }\r\n  var styleElement = options.insertStyleElement(options);\r\n  return {\r\n    update: function update(obj) {\r\n      apply(styleElement, options, obj);\r\n    },\r\n    remove: function remove() {\r\n      removeStyleElement(styleElement);\r\n    }\r\n  };\r\n}\r\nmodule.exports = domAPI;\n\n//# sourceURL=webpack:///./node_modules/style-loader/dist/runtime/styleDomAPI.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

eval("\r\n\r\n/* istanbul ignore next  */\r\nfunction styleTagTransform(css, styleElement) {\r\n  if (styleElement.styleSheet) {\r\n    styleElement.styleSheet.cssText = css;\r\n  } else {\r\n    while (styleElement.firstChild) {\r\n      styleElement.removeChild(styleElement.firstChild);\r\n    }\r\n    styleElement.appendChild(document.createTextNode(css));\r\n  }\r\n}\r\nmodule.exports = styleTagTransform;\n\n//# sourceURL=webpack:///./node_modules/style-loader/dist/runtime/styleTagTransform.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _index_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.css */ \"./src/index.css\");\n/* harmony import */ var _print_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./print.js */ \"./src/print.js\");\n \r\n\r\n\r\n\"use strict\";\r\n\r\n(0,_print_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])();\r\n\r\n/* #region Notes*/\r\n\r\n// timeToCast converts to the following:\r\n// Reaction = 1\r\n// Bonus Action = 2\r\n// Action = 3\r\n// Type of Weapons:\r\n// Melee = 1\r\n// Ranged = 2\r\n// Magic = 3\r\n// TODO: Must make ID's for everything, to make them easier to handle.\r\n// TODO: I am copying data too much, all characters should REFERENCE ability data etc, this will make it easier to code and should improve performance.\r\n\r\n/* #endregion Notes*/\r\n\r\n/* #region  Combat Log */\r\n\r\nconst combatLog = {\r\n    critHit: function (caster, target, damage) {\r\n        let damageDisplayArray = this.damageDisplay(damage);\r\n        let targetDamageSplit = Math.floor((damageDisplayArray[1] * 2) / 2);\r\n        let guardDamageSplit = Math.ceil((damageDisplayArray[1] * 2) / 2);\r\n        if (target.buffs.guarded) {\r\n            console.log(`${caster.name} CRITICALLY HITS ${target.name} and rolls a ${damageDisplayArray[0]} times 2 for a total of ${damageDisplayArray[1] * 2} damage, but because ${target.name} is guarded, the damage is split between him and his guard ${target.buffs.guarded.caster.name}, ${target.name} takes ${targetDamageSplit} and ${target.buffs.guarded.caster.name} takes ${guardDamageSplit}.`);\r\n        } else {\r\n            console.log(`${caster.name} CRITICALLY HITS ${target.name} and rolls a ${damageDisplayArray[0]} times 2 for a total of ${damageDisplayArray[1] * 2} damage!`)\r\n        }\r\n    },\r\n    attackAttempt: function (caster, target, attackRoll, defendRoll, attackBonus, defendBonus, ability) {\r\n        const attack = attackRoll + attackBonus;\r\n        const defend = defendRoll + defendBonus;\r\n        console.log(`${caster.name} attacks ${target.name} with: ${caster.equipment.mainHand.name} using: ${ability.name}, \r\n            with an attack roll of: ${attackRoll} and attack bonus of ${attackBonus} \r\n            against a defend roll of ${defendRoll} and a defend bonus of ${defendBonus}. \r\n            Total Attack: ${attack} vs. Total Defend: ${defend}`);\r\n    },\r\n    damageDisplay: function (damage) {\r\n        let damageRollDisplay = [];\r\n        damageRollDisplay[0] = ``;\r\n        if (sumOfArray(damage) < 1) {\r\n            damageRollDisplay[1] = 1;\r\n        } else {\r\n            damageRollDisplay[1] = sumOfArray(damage);\r\n        }\r\n        let damageBonus = popArrayPopValue(damage);\r\n        let damageCopy = popArrayArrayValue(damage);\r\n        for (let i = 0; i < damageCopy.length; i++) {\r\n            damageRollDisplay[0] += `${damageCopy[i]} + `\r\n        }\r\n        damageRollDisplay[0] += `a ${damageBonus} bonus`;\r\n\r\n        return damageRollDisplay;\r\n    },\r\n    hit: function (caster, target, damage) {\r\n        console.log(damage);\r\n        let damageDisplayArray = this.damageDisplay(damage); // * damageDisplayArray is an array with the index[0]\r\n        let targetDamageSplit = Math.floor((damageDisplayArray[1]) / 2);\r\n        let guardDamageSplit = Math.ceil((damageDisplayArray[1]) / 2);\r\n        if (target.buffs.guarded) {\r\n            console.log(`${caster.name} hits ${target.name} and rolls a ${damageDisplayArray[0]} for a total of ${damageDisplayArray[1]} damage, but because ${target.name} is guarded, the damage is split between him and his guard ${target.buffs.guarded.caster.name}, ${target.name} takes ${targetDamageSplit} and ${target.buffs.guarded.caster.name} will take ${guardDamageSplit} but has a chance to defend it.`);\r\n        } else {\r\n            console.log(`${caster.name} hits ${target.name} and rolls a ${damageDisplayArray[0]} for a total of ${damageDisplayArray[1]} damage.`);\r\n        }\r\n\r\n    },\r\n    hitBackupCopy: function (caster, target, damage) {\r\n        let damageDisplayArray = this.damageDisplay(damage); // * damageDisplayArray is an array with the index[0]\r\n        let targetDamageSplit = Math.floor((damageDisplayArray[1]) / 2);\r\n        let guardDamageSplit = Math.ceil((damageDisplayArray[1]) / 2);\r\n        if (target.buffs.guarded) {\r\n            console.log(`${caster.name} hits ${target.name} and rolls a ${damageDisplayArray[0]} for a total of ${damageDisplayArray[1]} damage, but because ${target.name} is guarded, the damage is split between him and his guard ${target.buffs.guarded.caster.name}, ${target.name} takes ${targetDamageSplit} and ${target.buffs.guarded.caster.name} will take ${guardDamageSplit} but has a chance to defend it.`);\r\n        } else {\r\n            console.log(`${caster.name} hits ${target.name} and rolls a ${damageDisplayArray[0]} for a total of ${damageDisplayArray[1]} damage.`);\r\n        }\r\n\r\n    },\r\n    defend: function (caster, target) {\r\n        console.log(`${target.name} defends ${caster.name}'s attack!`);\r\n    },\r\n    guardDefend: function (caster, target, guard) {\r\n        console.log(`${guard.name} defends the incoming damage from ${caster.name} redirected to him from his guard target ${target}!`)\r\n    },\r\n    guardFailsDefend: function (caster, target, guard) {\r\n        console.log(`${guard.name} does not defend the incoming damage from ${caster.name} redirected to him from his guard target ${target.name}, ${guard.name} takes the damage.`)\r\n    },\r\n    critHeal: function (caster, target, healAmountRoll, healBonus, healAmount) {\r\n        console.log(`${caster.name} CRITICALLY HEALS ${target.name} and rolls a ${healAmountRoll} with a ${healBonus} bonus times 2 for a total of ${healAmount} healing!`)\r\n    },\r\n    healAttempt: function (caster, target, healRoll, healBonus) {\r\n        console.log(`${caster.name} attempts to heal ${target.name} with a roll of: ${healRoll}.`)\r\n    },\r\n    heal: function (caster, target, healAmountRoll, healBonus, healAmount) {\r\n        console.log(`${caster.name} heals ${target.name} with a heal roll of ${healAmountRoll} and a ${healBonus} bonus for a total of ${healAmount} healing!`)\r\n    },\r\n    healFail: function (caster, target) {\r\n        console.log(`${caster.name} fails to heal ${target.name}!`)\r\n    },\r\n    noAP: function (abilityName, abilityAPCost) {\r\n        console.log(`Not enough AP to cast ${abilityName}. Total AP: ${turn.AP} - Ability Cost: ${abilityAPCost} `)\r\n    },\r\n    charIsDead: function (char, ability) {\r\n        console.log(`${char.name} cannot cast ${ability.name} while he is dead!`);\r\n    },\r\n    guard: function (caster, target) {\r\n        console.log(`${caster.name} casts his Guard onto ${target.name}.`);\r\n    },\r\n    guardSwitch: function (caster, target) {\r\n        console.log(`${caster.name} switches his Guard from ${caster.buffs.guarding.target.name} to ${target.name}.`);\r\n    },\r\n    riposte: function (caster, target) {\r\n        console.log(`${caster.name} defends well enough to attempt a riposte on ${target.name}.`)\r\n    },\r\n    startNPCTurn: function () {\r\n        console.log(`\r\n            Start NPC Turn:\r\n            `);\r\n    },\r\n    startPCTurn: function () {\r\n        console.log(`\r\n            Start PC Turn:\r\n            `);\r\n    },\r\n    casterOnlyBuff: function (caster, buff) {\r\n        console.log(`${caster.name} casts ${buff.name} on himself.`);\r\n    },\r\n    debuff: function (caster, target, targetDebuff) {\r\n        console.log(`${caster.name} casts ${targetDebuff.name} onto ${target.name}.`)\r\n    },\r\n    targetNotInRange: function (target, abilityName) {\r\n        console.log(`${target.name} is not in range for ${abilityName} to hit them!`);\r\n    },\r\n    damageResist: {\r\n        0: function (damage, resist, damageSum, caster, target) { //* Takes in the damage and resist number for this specific resistance and logs out the aftermath.\r\n            console.log(`${caster.name} deals out ${damage} flat damage against ${target.name}'s ${resist} flat resistance. ${target.name} takes ${damageSum} flat damage.`);\r\n        },\r\n        1: function (damage, resist, damageSum, caster, target) { //* Takes in the damage and resist number for this specific resistance and logs out the aftermath.\r\n            console.log(`${caster.name} deals out ${damage} piercing damage against ${target.name}'s ${resist} piercing resistance. ${target.name} takes ${damageSum} piercing damage.`);\r\n        },\r\n        2: function (damage, resist, damageSum, caster, target) { //* Takes in the damage and resist number for this specific resistance and logs out the aftermath.\r\n            console.log(`${caster.name} deals out ${damage} ice damage against ${target.name}'s ${resist} ice resistance. ${target.name} takes ${damageSum} ice damage.`);\r\n        },\r\n        3: function (damage, resist, damageSum, caster, target) { //* Takes in the damage and resist number for this specific resistance and logs out the aftermath.\r\n            console.log(`${caster.name} deals out ${damage} fire damage against ${target.name}'s ${resist} fire resistance. ${target.name} takes ${damageSum} fire damage.`);\r\n        },\r\n        4: function (damage, resist, damageSum, caster, target) { //* Takes in the damage and resist number for this specific resistance and logs out the aftermath.\r\n            console.log(`${caster.name} deals out ${damage} corrosive damage against ${target.name}'s ${resist} corrosive resistance. ${target.name} takes ${damageSum} corrosive damage.`);\r\n        },\r\n        5: function (damage, resist, damageSum, caster, target) { //* Takes in the damage and resist number for this specific resistance and logs out the aftermath.\r\n            console.log(`${caster.name} deals out ${damage} poison damage against ${target.name}'s ${resist} poison resistance. ${target.name} takes ${damageSum} poison damage.`);\r\n        },\r\n        6: function (damage, resist, damageSum, caster, target) { //* Takes in the damage and resist number for this specific resistance and logs out the aftermath.\r\n            console.log(`${caster.name} deals out ${damage} spiritual damage against ${target.name}'s ${resist} spiritual resistance. ${target.name} takes ${damageSum} spiritual damage.`);\r\n        },\r\n        7: function (damage, resist, damageSum, caster, target) { //* Takes in the damage and resist number for this specific resistance and logs out the aftermath.\r\n            console.log(`${caster.name} deals out ${damage} lightning damage against ${target.name}'s ${resist} lightning resistance. ${target.name} takes ${damageSum} lightning damage.`);\r\n        },\r\n        8: function (damage, resist, damageSum, caster, target) { //* Takes in the damage and resist number for this specific resistance and logs out the aftermath.\r\n            console.log(`${caster.name} deals out ${damage} arcane damage against ${target.name}'s ${resist} arcane resistance. ${target.name} takes ${damageSum} arcane damage.`);\r\n        },\r\n    }\r\n}\r\n\r\n/* #endregion Combat Log*/\r\n\r\n/* #region  Ability Effects & Logic */ \r\n\r\nconst turn = {\r\n    AP: 100,\r\n    end: function () {\r\n        combatLog.startNPCTurn();\r\n        this.AP = 100;\r\n        while (this.AP > 0) { // TODO: Need to fix this big time.\r\n            // const attackingNPC = NPCs.charList[dice(NPCs.charList.length - 1)];\r\n            // attackingNPC.useAbility( attackingNPC.abilities[dice(attackingNPC.abilities.length - 1)] ,PCs.charList[dice(PCs.charList.length - 1)]);\r\n            const attackingNPC = NPCs.charList[diceMinus1(NPCs.charList.length)];\r\n            attackingNPC.useAbility(0, PCs.charList[diceMinus1(PCs.charList.length)]);\r\n        };\r\n        this.AP = 100;\r\n        DOM.update();\r\n        DOM.updateTopBar();\r\n        combatLog.startPCTurn();\r\n    },\r\n}\r\n\r\nconst effect = {\r\n    meleeAttack: function (caster, target, mods) {\r\n        const ability = allAbilities[mods.abilityIndex];\r\n        let riposte = false;\r\n        let damageSum;\r\n\r\n        /* #region  CASTER ATTACK */\r\n        let attackRollAdvantages = calcTargetAttackAdvatages(caster);\r\n        let attackRoll = rollWithAdvantageCount(100, attackRollAdvantages);\r\n        const attack = attackRoll + mods.attackBonus;\r\n        /* #endregion */\r\n\r\n        /* #region  TARGET DEFEND */\r\n        let defendRollAdvantages = calcTargetDefendAdvatages(target);\r\n        let defendRoll = rollWithAdvantageCount(20, defendRollAdvantages);\r\n        const defend = defendRoll + mods.getDefendBonus();\r\n        /* #endregion */\r\n\r\n        combatLog.attackAttempt(caster, target, attackRoll, defendRoll, mods.attackBonus, mods.getDefendBonus(), ability);\r\n\r\n        /* #region  CHECK & SET RIPOSTE */\r\n        if (!mods.isRiposte) {\r\n            if ((Math.ceil(attack / 2)) <= defend) {\r\n                riposte = true\r\n            }\r\n        }\r\n        /* #endregion */\r\n\r\n        /* #region  IF TARGET DEFENDS ATTACK */\r\n        if (attack <= defend) {\r\n            combatLog.defend(caster, target);\r\n            if (riposte) {\r\n                combatLog.riposte(target, caster);\r\n                target.useAbility(9, caster);\r\n            }\r\n            return;\r\n        }\r\n        /* #endregion */\r\n\r\n        const damageRollArr = concatRollDice(mods.damageRollDice.mainHandWeapon, mods.damageRollDice.offHandWeapon, mods.damageRollDice.ability);\r\n        console.log(`Damage Bonus Log: ${mods.damageBonus}`);\r\n        damageRollArr.push(mods.damageBonus);\r\n        const totalDamagePerResist = sumOfDamageArray(damageRollArr);\r\n\r\n        if (attackRoll >= mods.critThreshold) { // * ON CRIT\r\n            combatLog.critHit(caster, target, damageRollArr);\r\n\r\n            if (sumOfArray(damageRollArr) < 1) {\r\n                target.hp -= 2;\r\n            } else { // * Resistances and buff and debuff checks all go here\r\n\r\n                if (target.buffs.guarded) {\r\n                    totalDamage = sumOfArray(damageRollArr) * mods.critMultiplier;\r\n                    targetDamage = Math.floor(totalDamage / 2);\r\n                    guardDamage = Math.ceil(totalDamage / 2);\r\n                    target.hp -= targetDamage;\r\n                    target.buffs.guarded.caster.hp -= guardDamage\r\n                } else {\r\n                    target.hp -= sumOfArray(damageRollArr) * mods.critMultiplier;\r\n                }\r\n            }\r\n            return;\r\n        }\r\n        console.log(damageRollArr)\r\n        combatLog.hit(caster, target, damageRollArr); // * ON HIT\r\n\r\n        if (riposte) {\r\n            combatLog.riposte(target, caster);\r\n            target.useAbility(9, caster);\r\n        }\r\n\r\n        if (target.buffs.guarded) {\r\n            const guardDefense = getGuardDefense(`melee`, target.buffs.guarded.caster);\r\n            targetDamage = calcTargetWithGuardDamage(totalDamagePerResist, target.resistsArray, caster, target);\r\n            target.hp -= targetDamage;\r\n            if (attack > guardDefense) {\r\n                combatLog.guardFailsDefend(caster, target, target.buffs.guarded.caster);\r\n                guardDamage = calcGuardDamage(totalDamagePerResist, target.buffs.guarded.caster.resistsArray, caster, target.buffs.guarded.caster);\r\n                target.buffs.guarded.caster.hp -= guardDamage;\r\n            } else {\r\n                combatLog.guardDefend(caster, target, target.buffs.guarded.caster);\r\n            }\r\n        } else {\r\n            damageSum = calcTotalDamageAfterResists(totalDamagePerResist, target.resistsArray, caster, target); // * also calls combatLog()\r\n            target.hp -= sumOfArray(damageSum); \r\n        }\r\n        \r\n        return;\r\n    },\r\n\r\n    // rangedAttack: function (caster, target) {\r\n    //     const mods = {\r\n    //         attackRollDice: 100,\r\n    //         attackBonus: caster.stats.dexterity,\r\n    //         defendRollDice: 20,\r\n    //         defendBonus\r\n\r\n    //     }\r\n    //     const attackRoll = dice(100);\r\n    //     const defendRoll = dice(20);\r\n    //     const attackBonus = caster.stats.dexterity;\r\n    //     const defendBonus = this.determineDefendBonus(caster, target);\r\n    //     const damage = this.determineDamage(caster);\r\n    //     const attack = attackRoll + attackBonus;\r\n    //     const defend = defendRoll + defendBonus;\r\n    //     if (attackRoll === 100) {\r\n    //         combatLog.critHit(caster, target, damage);\r\n    //         if (sumOfArray(damage) < 1) {\r\n    //             target.hp -= 2;\r\n    //         } else {\r\n    //             target.hp -= sumOfArray(damage) * 2;\r\n    //         }\r\n    //     } else {\r\n    //         combatLog.attackAttempt(caster, target, attackRoll, defendRoll, attackBonus, defendBonus);\r\n    //         if (attack >= defend) {\r\n    //             combatLog.hit(caster, target, damage);\r\n    //             if (sumOfArray(damage) < 1) {\r\n    //                 target.hp -= 1;\r\n    //             } else {\r\n    //                 target.hp -= sumOfArray(damage);\r\n    //             }\r\n    //         } else {\r\n    //             combatLog.defend(caster, target);\r\n    //         }\r\n    //     }\r\n    // },\r\n\r\n    // magicalAttack: function (caster, target) {\r\n    //     const mods = {\r\n    //         attackRollDice: 100,\r\n    //         attackBonus: caster.stats.dexterity,\r\n    //         defendRollDice: 20,\r\n    //         defendBonus\r\n\r\n    //     }\r\n    //     const attackRoll = dice(100);\r\n    //     const defendRoll = dice(20);\r\n    //     const attackBonus = caster.stats.dexterity;\r\n    //     const defendBonus = this.determineDefendBonus(caster, target);\r\n    //     const damage = this.determineDamage(caster);\r\n    //     const attack = attackRoll + attackBonus;\r\n    //     const defend = defendRoll + defendBonus;\r\n    //     if (attackRoll === 100) {\r\n    //         combatLog.critHit(caster, target, damage);\r\n    //         if (sumOfArray(damage) < 1) {\r\n    //             target.hp -= 2;\r\n    //         } else {\r\n    //             target.hp -= sumOfArray(damage) * 2;\r\n    //         }\r\n    //     } else {\r\n    //         combatLog.attackAttempt(caster, target, attackRoll, defendRoll, attackBonus, defendBonus);\r\n    //         if (attack >= defend) {\r\n    //             combatLog.hit(caster, target, damage);\r\n    //             if (sumOfArray(damage) < 1) {\r\n    //                 target.hp -= 1;\r\n    //             } else {\r\n    //                 target.hp -= sumOfArray(damage);\r\n    //             }\r\n    //         } else {\r\n    //             combatLog.defend(caster, target);\r\n    //         }\r\n    //     }\r\n    // },\r\n\r\n    heal: function (caster, target) {\r\n        const healRoll = dice(100);\r\n        const healAmountRoll = dice(4);\r\n        const healBonus = caster.stats.willpower;\r\n        const healAmount = healAmountRoll + healBonus;\r\n        if (healRoll === 100) {\r\n            combatLog.critHeal(caster, target, healAmountRoll, healBonus, healAmount);\r\n            if (healAmount < 1) {\r\n                target.hp += 2;\r\n            } else {\r\n                target.hp += healAmount * 2;\r\n            }\r\n        } else {\r\n            combatLog.healAttempt(caster, target, healRoll, healBonus);\r\n            if (healRoll > 1) {\r\n                combatLog.heal(caster, target, healAmountRoll, healBonus, healAmount);\r\n                if (healAmount < 1) {\r\n                    target.hp += 1;\r\n                } else {\r\n                    target.hp += healAmount;\r\n                }\r\n            } else {\r\n                combatLog.healFail(caster, target);\r\n            }\r\n        }\r\n    },\r\n\r\n    guard: function (caster, target, mods) { // * For every attack made on the target, the caster takes half of that damage.\r\n        const targetBuff = {\r\n            name: mods.buffNameForTarget,\r\n            desc: mods.buffDescForTarget,\r\n            caster: caster,\r\n        }\r\n        const casterBuff = {\r\n            name: mods.buffNameForCaster,\r\n            desc: mods.buffDescForCaster,\r\n            target: target,\r\n        }\r\n        target.buffs.guarded = targetBuff;\r\n        if (caster.buffs.guarding) {\r\n            combatLog.guardSwitch(caster, target);\r\n            delete caster.buffs.guarding.target.buffs.guarded;\r\n            delete caster.buffs.guarding;\r\n            caster.buffs.guarding = casterBuff;\r\n        } else {\r\n            combatLog.guard(caster, target);\r\n            caster.buffs.guarding = casterBuff;\r\n        }\r\n    },\r\n    casterOnlyBuff: function (caster, mods) { // * Buff\r\n        const buff = mods;\r\n        caster.buffs[mods.buffNameForBuffObj] = buff;\r\n        combatLog.casterOnlyBuff(caster, buff);\r\n    },\r\n    debuff: function (caster, target, mods) { // * Buff\r\n        const targetDebuff = mods;\r\n        target.debuffs[mods.debuffNameForBuffObj] = targetDebuff;\r\n        combatLog.debuff(caster, target, targetDebuff);\r\n    },\r\n};\r\n/* #region  LOGIC */\r\nfunction calcGuardDamage(damage, resists, caster, target) { // * Takes two 9 index long resist arrays, outputs the aftermath of damage divided for the guard.\r\n    let damageSum = [0,0,0,0,0,0,0,0,0];\r\n    for(let i = 0; i < 9; i++) { // * cycles 9 times for each resist\r\n        if(damage[i] > 0) { // * If the damage is more than 0\r\n            if(resists[i] >=  damage[i]) {  // * If the resist is more than or equal to the damage, then 1 damage is taken.\r\n                damageSum[i] += 1;\r\n            } else if(resists[i] < 0){  // * If the resist is negative\r\n                if((resists[i] * -1) > damage[i]) { // * If the resist is more negative than the damage is positive, we just multiply the damage by 2, because a vulnerability cant do more than the original damage.\r\n                    damageSum[i] += damage[i] * 2;\r\n                } else { // * If the resist is negative, and all of it will be taken as damage, because the damage is higher than it.\r\n                    damageSum[i] += damage[i] + (resists[i] * -1);\r\n                }\r\n            } else { // * If the resist is positive, but is less than the total damage.\r\n                damageSum[i] += (damage[i] - resists[i])\r\n            }\r\n            damageSum[i] = Math.floor(damageSum[i] / 2);\r\n            combatLog.damageResist[i](damage[i], resists[i], damageSum[i], caster, target);\r\n        } else if (damageSum[i] < 0){ // * if the damage is negative, then 1 damage is taken, because you cannot deal negative damage on an attack.\r\n            damageSum[i] = Math.floor(damageSum[i] / 2);\r\n            combatLog.damageResist[i](damage[i], resists[i], damageSum[i], caster, target);\r\n            damageSum[i] += 1;\r\n        } else {\r\n            damageSum[i] = 0;\r\n        }\r\n    }\r\n    return damageSum;\r\n}\r\n\r\nfunction calcTargetWithGuardDamage(damage, resists, caster, target) { // * Takes two 9 index long resist arrays, outputs the aftermath of damage divided for target with guard.\r\n    let damageSum = [0,0,0,0,0,0,0,0,0];\r\n    for(let i = 0; i < 9; i++) { // * cycles 9 times for each resist\r\n        if(damage[i] > 0) { // * If the damage is more than 0\r\n            if(resists[i] >=  damage[i]) {  // * If the resist is more than or equal to the damage, then 1 damage is taken.\r\n                damageSum[i] += 1;\r\n            } else if(resists[i] < 0){  // * If the resist is negative\r\n                if((resists[i] * -1) > damage[i]) { // * If the resist is more negative than the damage is positive, we just multiply the damage by 2, because a vulnerability cant do more than the original damage.\r\n                    damageSum[i] += damage[i] * 2;\r\n                } else { // * If the resist is negative, and all of it will be taken as damage, because the damage is higher than it.\r\n                    damageSum[i] += damage[i] + (resists[i] * -1);\r\n                }\r\n            } else { // * If the resist is positive, but is less than the total damage.\r\n                damageSum[i] += (damage[i] - resists[i])\r\n            }\r\n            damageSum[i] = Math.ceil(damageSum[i] / 2);\r\n            combatLog.damageResist[i](damage[i], resists[i], damageSum[i], caster, target);\r\n        } else if (damageSum[i] < 0){ // * if the damage is negative, then 1 damage is taken, because you cannot deal negative damage on an attack.\r\n            damageSum[i] = Math.ceil(damageSum[i] / 2);\r\n            combatLog.damageResist[i](damage[i], resists[i], damageSum[i], caster, target);\r\n            damageSum[i] += 1;\r\n        } else {\r\n            damageSum[i] = 0;\r\n        }\r\n    }\r\n    return damageSum;\r\n}\r\n\r\nfunction calcTotalDamageAfterResists(damage, resists, caster, target) { // * Takes two 9 index long resist arrays, outputs the aftermath of damage.\r\n    let damageSum = [0,0,0,0,0,0,0,0,0];\r\n    for(let i = 0; i < 9; i++) { // * cycles 9 times for each resist\r\n        if(damage[i] > 0) { // * If the damage is more than 0\r\n            if(resists[i] >=  damage[i]) {  // * If the resist is more than or equal to the damage, then 1 damage is taken.\r\n                damageSum[i] += 1;\r\n            } else if(resists[i] < 0){  // * If the resist is negative\r\n                if((resists[i] * -1) > damage[i]) { // * If the resist is more negative than the damage is positive, we just multiply the damage by 2, because a vulnerability cant do more than the original damage.\r\n                    damageSum[i] += damage[i] * 2;\r\n                } else { // * If the resist is negative, and all of it will be taken as damage, because the damage is higher than it.\r\n                    damageSum[i] += damage[i] + (resists[i] * -1);\r\n                }\r\n            } else { // * If the resist is positive, but is less than the total damage.\r\n                damageSum[i] += (damage[i] - resists[i])\r\n            }\r\n            combatLog.damageResist[i](damage[i], resists[i], damageSum[i], caster, target);\r\n        } else if (damageSum[i] < 0){ // * if the damage is negative, then 1 damage is taken, because you cannot deal negative damage on an attack.\r\n            combatLog.damageResist[i](damage[i], resists[i], damageSum[i], caster, target);\r\n            damageSum[i] += 1;\r\n        } else {\r\n            damageSum[i] = 0;\r\n        }\r\n    }\r\n    return damageSum;\r\n}\r\n\r\nfunction calcTargetAttackAdvatages(caster) { // * Takes target as input, returns the total advantage count for their defend roll, counting buffs and debuffs.\r\n    let attackRollAdvantages = [];\r\n    Object.keys(caster.buffs).forEach((buffKey) => {\r\n        if (caster.buffs[buffKey].attackRollAdvantage) {\r\n            attackRollAdvantages.push(caster.buffs[buffKey].attackRollAdvantage);\r\n        }\r\n    });\r\n    Object.keys(caster.debuffs).forEach((buffKey) => {\r\n        if (caster.buffs[buffKey].attackRollAdvantage) {\r\n            attackRollAdvantages.push(caster.buffs[buffKey].attackRollAdvantage);\r\n        }\r\n    });\r\n    return sumOfArray(attackRollAdvantages);\r\n}\r\n\r\nfunction calcTargetDefendAdvatages(target) { // * Takes target as input, returns the total advantage count for their defend roll, counting buffs and debuffs.\r\n    let defendRollAdvantages = [];\r\n    Object.keys(target.buffs).forEach((buffKey) => {\r\n        if (target.buffs[buffKey].defendRollAdvantage) {\r\n            defendRollAdvantages.push(target.buffs[buffKey].defendRollAdvantage);\r\n        }\r\n    });\r\n    Object.keys(target.debuffs).forEach((buffKey) => {\r\n        if (target.buffs[buffKey].defendRollAdvantage) {\r\n            defendRollAdvantages.push(target.buffs[buffKey].defendRollAdvantage);\r\n        }\r\n    });\r\n    return sumOfArray(defendRollAdvantages);\r\n}\r\n\r\nfunction rollWithAdvantageCount(diceSize, advantageCount) { // * Takes a dice size input, and a advantage or disadvantage count input (pos 1 will be a regular roll, lower will be disadvantage and higher will be advantage) returns the highest or lowest number respectiveley.\r\n    let arrOfRolls = [];\r\n    let isAdvantageCountPos;\r\n    if (advantageCount < 0) {\r\n        advantageCount *= -1;\r\n        isAdvantageCountPos = false;\r\n    } else {\r\n        isAdvantageCountPos = true;\r\n    }\r\n    advantageCount += 1;\r\n    for (let i = 0; i < advantageCount; i++) {\r\n        arrOfRolls.push(dice(diceSize))\r\n    };\r\n    if (isAdvantageCountPos) {\r\n        return Math.max(...arrOfRolls);\r\n    } else {\r\n        return Math.min(...arrOfRolls);\r\n    }\r\n}\r\n\r\nfunction getGuardDefense(attackType, guarder) {\r\n    const guarderBlock = Math.floor((guarder.stats.initiative / 2) + guarder.block);\r\n    let returnValue;\r\n    switch (attackType) {\r\n        case `melee`:\r\n            const guarderParry = Math.floor((guarder.stats.initiative / 2) + (guarder.stats.dexterity / 4) + guarder.parry);\r\n            returnValue = Math.max(guarderParry, guarderBlock);\r\n            break;\r\n        case `ranged`:\r\n            const guarderDodge = Math.floor((guarder.stats.initiative / 2) + (guarder.stats.agility / 4) + guarder.dodge);\r\n            returnValue = Math.max(guarderDodge, guarderBlock);\r\n            break;\r\n        case `magic`:\r\n            const guarderDisrupt = Math.floor((guarder.stats.initiative / 2) + (guarder.stats.willpower / 4) + guarder.disrupt);\r\n            returnValue = Math.max(guarderDisrupt, guarderBlock);\r\n            break;\r\n    }\r\n    return returnValue;\r\n}\r\n\r\nfunction doesArrayOfObjectsIncludeIndexOf(array, propertyName, value) {\r\n    array.forEach((ele) => {\r\n        if (ele[propertyName] === value) {\r\n            let index = array.indexOf(ele);\r\n            return index;\r\n        }\r\n        return false;\r\n    });\r\n}\r\n\r\nfunction doesArrayOfObjectsInclude(array, propertyName, value) {\r\n    array.forEach((ele) => {\r\n        if (ele[propertyName] === value) {\r\n            return true;\r\n        }\r\n        return false;\r\n    });\r\n}\r\n\r\nfunction concatRollDice(...args) { // * Takes multiple 2D dice array input like rollDice does, but outputs will ignore null inputs.\r\n    let outputArr = [];\r\n    args.forEach((el) => {\r\n        if (el) {\r\n            let i = rollDice(el);\r\n            outputArr = outputArr.concat(i);\r\n        }\r\n    });\r\n    return outputArr;\r\n}\r\n\r\nfunction rollDice(diceArr) { // * Takes a 2D dice array input like so: [ [2,4] , [3,6] ] - equivilent to 2d4 + 3d6. Outputs array of each individual roll result, now with resistances.\r\n    if (diceArr === null) {\r\n        return null;\r\n    }\r\n    let rollArr = [];\r\n    for (let i = 0; i < diceArr.length; i++) {\r\n        for (let x = 0; x < diceArr[i][1]; x++) {\r\n\r\n            rollArr.push([diceArr[i][0],dice(diceArr[i][2])]);\r\n        }\r\n    }\r\n    return rollArr;\r\n}\r\n\r\nfunction dice(dMax) { // * Takes an integer number X as input and outputs a random number between 1 and X like a single dice roll.\r\n    return Math.floor(Math.random() * dMax + 1);\r\n}\r\n\r\nfunction diceMinus1(dMax) { // * Takes an integer number X as input and outputs a random number between 0 and X.\r\n    return Math.floor(Math.random() * dMax + 1) - 1;\r\n}\r\n\r\nfunction sumOfDamageArray(arrayOfNumbers) { // * Takes a 2D array of numbers and adds the index [1's] up, then returns an array 9 indexes long representing each damage resist type, and how much of that type was sumed.\r\n    if (arrayOfNumbers === null) {\r\n        return null;\r\n    }\r\n    let sum = [0,0,0,0,0,0,0,0,0];\r\n    for (let i = 0; i < arrayOfNumbers.length; i++) {\r\n        sum[arrayOfNumbers[i][0]] += arrayOfNumbers[i][1];\r\n    }\r\n    return sum;\r\n}\r\n\r\nfunction sumOfArray(arrayOfNumbers) { // * Takes a 1D array of numbers and adds them up, then returns the sum.\r\n    let sum = 0;\r\n    arrayOfNumbers.forEach((el) => { if (el === null) { el = 0 } sum += el });\r\n    return sum;\r\n}\r\n\r\nfunction popArrayPopValue(array) {\r\n    let arrayCopy = Object.assign([], array);\r\n    return arrayCopy.pop();\r\n}\r\n\r\nfunction popArrayArrayValue(array) {\r\n    let arrayCopy = Object.assign([], array);\r\n    arrayCopy.pop();\r\n    return arrayCopy;\r\n}\r\n\r\nfunction isTargetDead(target) {\r\n    if (target.hp < 1) {\r\n        console.log(`Target is dead.`)\r\n        return true\r\n    }\r\n}\r\n\r\nfunction isAttackingAllies(caster, target) {\r\n    if (caster.groupName === `PC` && target.groupName === `PC`) {\r\n        console.log(`Don't attack your allies!`);\r\n        return true\r\n    }\r\n    if (caster.groupName === `NPC` && target.groupName === `NPC`) {\r\n        return true\r\n    }\r\n    return false;\r\n};\r\n\r\nfunction isHealingEnemies(caster, target) {\r\n    if (caster.groupName === `PC` && target.groupName === `NPC`) {\r\n        console.log(`Don't heal the enemy!`);\r\n        return true\r\n    }\r\n    if (caster.groupName === `NPC` && target.groupName === `PC`) {\r\n        return true\r\n    }\r\n    return false;\r\n};\r\n\r\nfunction isBuffingEnemies(caster, target) {\r\n    if (caster.groupName === `PC` && target.groupName === `NPC`) {\r\n        console.log(`Don't buff the enemy!`);\r\n        return true\r\n    }\r\n    if (caster.groupName === `NPC` && target.groupName === `PC`) {\r\n        return true\r\n    }\r\n    return false;\r\n};\r\n\r\nfunction isHealingDeadTarget(target, abilityName) {\r\n    if (target.hp < 1) {\r\n        console.log(`${abilityName} is not powerful enough to ressurect ${target.name}.`)\r\n        return true\r\n    }\r\n};\r\n\r\nfunction forceHPtoZero(char) {\r\n    if (char.hp < 0) {\r\n        char.hp = 0;\r\n    }\r\n};\r\n\r\nfunction isTargetInRangeOfCaster(caster, target, abilityRange) {\r\n    let casterRowConverted;\r\n    let targetRowConverted;\r\n    if (caster.groupName !== target.groupName) {\r\n        if(caster.groupName === `PC`) {\r\n            switch (caster.row) {\r\n                case 3:\r\n                    casterRowConverted = 6;\r\n                break;\r\n                case 2:\r\n                    casterRowConverted = 5;\r\n                break;\r\n                case 1:\r\n                    casterRowConverted = 4;\r\n                break;\r\n            }\r\n            switch (target.row) {\r\n                case 3:\r\n                    targetRowConverted = 1;\r\n                break;\r\n                case 2:\r\n                    targetRowConverted = 2;\r\n                break;\r\n                case 1:\r\n                    targetRowConverted = 3;\r\n                break;\r\n            }\r\n            if(Math.abs(casterRowConverted - targetRowConverted) <= abilityRange) {\r\n                return true;\r\n            } else {\r\n                return false;\r\n            }\r\n        }\r\n        if(caster.groupName === `NPC`) {\r\n            switch (caster.row) {\r\n                case 3:\r\n                    casterRowConverted = 1;\r\n                break;\r\n                case 2:\r\n                    casterRowConverted = 2;\r\n                break;\r\n                case 1:\r\n                    casterRowConverted = 3;\r\n                break;\r\n            }\r\n            switch (target.row) {\r\n                case 3:\r\n                    targetRowConverted = 6;\r\n                break;\r\n                case 2:\r\n                    targetRowConverted = 5;\r\n                break;\r\n                case 1:\r\n                    targetRowConverted = 4;\r\n                break;\r\n            }\r\n            if(Math.abs(casterRowConverted - targetRowConverted) <= abilityRange) {\r\n                return true;\r\n            } else {\r\n                return false;\r\n            }\r\n        }\r\n    } else {\r\n        if(caster.groupName === `PC`) {\r\n            switch (caster.row) {\r\n                case 3:\r\n                    casterRowConverted = 6;\r\n                break;\r\n                case 2:\r\n                    casterRowConverted = 5;\r\n                break;\r\n                case 1:\r\n                    casterRowConverted = 4;\r\n                break;\r\n            }\r\n            switch (target.row) {\r\n                case 3:\r\n                    targetRowConverted = 6;\r\n                break;\r\n                case 2:\r\n                    targetRowConverted = 5;\r\n                break;\r\n                case 1:\r\n                    targetRowConverted = 4;\r\n                break;\r\n            }\r\n            if((Math.abs(casterRowConverted - targetRowConverted) <= abilityRange)) {\r\n                return true;\r\n            } else {\r\n                return false;\r\n            }\r\n        }\r\n        if(caster.groupName === `NPC`) {\r\n            switch (caster.row) {\r\n                case 3:\r\n                    casterRowConverted = 1;\r\n                break;\r\n                case 2:\r\n                    casterRowConverted = 2;\r\n                break;\r\n                case 1:\r\n                    casterRowConverted = 3;\r\n                break;\r\n            }\r\n            switch (target.row) {\r\n                case 3:\r\n                    targetRowConverted = 1;\r\n                break;\r\n                case 2:\r\n                    targetRowConverted = 2;\r\n                break;\r\n                case 1:\r\n                    targetRowConverted = 3;\r\n                break;\r\n            }\r\n            if((Math.abs(casterRowConverted - targetRowConverted) <= abilityRange)) {\r\n                return true;\r\n            } else {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    \r\n};\r\n\r\n/* #endregion END LOGIC*/\r\n\r\n/* #endregion Ability Effects & Logic*/\r\n\r\n/* #region All Lists */\r\n\r\nconst allAbilities = [];\r\nfunction defineAllAbilities() {\r\n    allAbilities[0] = {\r\n        name: `Attack`,\r\n        effect: function (caster, target) {\r\n            if (!isAttackingAllies(caster, target)) {\r\n                if (!isTargetDead(target)) {\r\n                    if (turn.AP >= this.APCost) {\r\n                        const mods = {\r\n                            abilityIndex: 0,\r\n                            abilityRange: caster.equipment.mainHand.range,\r\n                            attackRollDice: 100,\r\n                            attackBonus: caster.stats.dexterity,\r\n                            damageRollDice: {\r\n                                mainHandWeapon: caster.equipment.mainHand.damage,\r\n                                offHandWeapon: caster.equipment.offHand.damage,\r\n                                ability: null,\r\n                            },\r\n                            damageBonus: [0, caster.stats.strength],\r\n                            critThreshold: 100,\r\n                            critMultiplier: 2,\r\n                            defendRollDice: 20,\r\n                            targetParry: Math.floor((target.stats.initiative / 2) + (target.stats.dexterity / 4) + target.parry),\r\n                            targetDodge: Math.floor((target.stats.initiative / 2) + (target.stats.agility / 4) + target.dodge),\r\n                            targetDisrupt: Math.floor((target.stats.initiative / 2) + (target.stats.willpower / 4) + target.disrupt),\r\n                            targetBlock: Math.floor((target.stats.initiative / 2) + target.block),\r\n                            getDefendBonus: function () {\r\n                                return Math.max(this.targetParry, this.targetBlock)\r\n                            },\r\n                        };\r\n                        if(isTargetInRangeOfCaster(caster, target, mods.abilityRange)) {\r\n                            effect.meleeAttack(caster, target, mods); turn.AP -= this.APCost\r\n                        } else {\r\n                            combatLog.targetNotInRange(target, this.name);\r\n                        }\r\n                    } else {\r\n                        combatLog.noAP(this.name, this.APCost);\r\n                    }\r\n                }\r\n            }\r\n        },\r\n        APCost: 20,\r\n    }\r\n    allAbilities[1] = {\r\n        name: `Powerful Strike`,\r\n        effect: function (caster, target) {\r\n            if (!isAttackingAllies(caster, target)) {\r\n                if (!isTargetDead(target)) {\r\n                    if (turn.AP >= this.APCost) {\r\n                        const mods = {\r\n                            abilityIndex: 1,\r\n                            abilityRange: 1,\r\n                            attackRollDice: 100,\r\n                            attackBonus: caster.stats.strength,\r\n                            damageRollDice: {\r\n                                mainHandWeapon: caster.equipment.mainHand.damage,\r\n                                offHandWeapon: caster.equipment.offHand.damage,\r\n                                ability: null,\r\n                            },\r\n                            damageBonus: Math.floor(caster.stats.strength * 1.5),\r\n                            critThreshold: 100,\r\n                            critMultiplier: 2,\r\n                            defendRollDice: 20,\r\n                            targetParry: Math.floor((target.stats.initiative / 2) + (target.stats.dexterity / 4) + target.parry),\r\n                            targetDodge: Math.floor((target.stats.initiative / 2) + (target.stats.agility / 4) + target.dodge),\r\n                            targetDisrupt: Math.floor((target.stats.initiative / 2) + (target.stats.willpower / 4) + target.disrupt),\r\n                            targetBlock: Math.floor((target.stats.initiative / 2) + target.block),\r\n                            getDefendBonus: function () {\r\n                                return Math.max(this.targetParry, this.targetBlock)\r\n                            },\r\n                        };\r\n                        if(isTargetInRangeOfCaster(caster, target, mods.abilityRange)) {\r\n                            effect.meleeAttack(caster, target, mods); turn.AP -= this.APCost\r\n                        } else {\r\n                            combatLog.targetNotInRange(target, this.name);\r\n                        }\r\n                    } else {\r\n                        combatLog.noAP(this.name, this.APCost);\r\n                    }\r\n                }\r\n            }\r\n        },\r\n        APCost: 25,\r\n    }\r\n    allAbilities[2] = {\r\n        name: `Precision Strike`,\r\n        effect: function (caster, target) {\r\n            if (!isAttackingAllies(caster, target)) {\r\n                if (!isTargetDead(target)) {\r\n                    if (turn.AP >= this.APCost) {\r\n                        const mods = {\r\n                            abilityIndex: 1,\r\n                            abilityRange: caster.equipment.mainHand.range,\r\n                            attackRollDice: 100,\r\n                            attackBonus: caster.stats.dexterity * 2,\r\n                            damageRollDice: {\r\n                                mainHandWeapon: caster.equipment.mainHand.damage,\r\n                                offHandWeapon: caster.equipment.offHand.damage,\r\n                                ability: null,\r\n                            },\r\n                            damageBonus: [0, Math.floor(caster.stats.dexterity * 1.5)],\r\n                            critThreshold: 100,\r\n                            critMultiplier: 2,\r\n                            defendRollDice: 20,\r\n                            targetParry: Math.floor((target.stats.initiative / 2) + (target.stats.dexterity / 4) + target.parry),\r\n                            targetDodge: Math.floor((target.stats.initiative / 2) + (target.stats.agility / 4) + target.dodge),\r\n                            targetDisrupt: Math.floor((target.stats.initiative / 2) + (target.stats.willpower / 4) + target.disrupt),\r\n                            targetBlock: Math.floor((target.stats.initiative / 2) + target.block),\r\n                            getDefendBonus: function () {\r\n                                return Math.max(this.targetParry, this.targetBlock)\r\n                            },\r\n                        };\r\n                        if(isTargetInRangeOfCaster(caster, target, mods.abilityRange)) {\r\n                            effect.meleeAttack(caster, target, mods); turn.AP -= this.APCost\r\n                        } else {\r\n                            combatLog.targetNotInRange(target, this.name);\r\n                        }\r\n                    } else {\r\n                        combatLog.noAP(this.name, this.APCost);\r\n                    }\r\n                }\r\n            }\r\n        },\r\n        APCost: 25,\r\n    }\r\n    allAbilities[3] = {\r\n        name: `Healing Word`,\r\n        effect: function (caster, target) {\r\n            if (!isHealingEnemies(caster, target)) {\r\n                if (!isHealingDeadTarget(target, this.name)) {\r\n                    if (turn.AP >= this.APCost) {\r\n                        const mods = {\r\n                            abilityIndex: 1,\r\n                            abilityRange: 1,\r\n                            attackRollDice: 100,\r\n                            attackBonus: caster.stats.dexterity * 2,\r\n                            damageRollDice: {\r\n                                mainHandWeapon: caster.equipment.mainHand.damage,\r\n                                offHandWeapon: caster.equipment.offHand.damage,\r\n                                ability: null,\r\n                            },\r\n                            damageBonus: Math.floor(caster.stats.dexterity * 1.5),\r\n                            critThreshold: 100,\r\n                            critMultiplier: 2,\r\n                            defendRollDice: 20,\r\n                            targetParry: Math.floor((target.stats.initiative / 2) + (target.stats.dexterity / 4) + target.parry),\r\n                            targetDodge: Math.floor((target.stats.initiative / 2) + (target.stats.agility / 4) + target.dodge),\r\n                            targetDisrupt: Math.floor((target.stats.initiative / 2) + (target.stats.willpower / 4) + target.disrupt),\r\n                            targetBlock: Math.floor((target.stats.initiative / 2) + target.block),\r\n                            getDefendBonus: function () {\r\n                                return Math.max(this.targetParry, this.targetBlock)\r\n                            },\r\n                        };\r\n                        if(isTargetInRangeOfCaster(caster, target, mods.abilityRange)) {\r\n                            effect.heal(caster, target); turn.AP -= this.APCost\r\n                        } else {\r\n                            combatLog.targetNotInRange(target, this.name);\r\n                        }\r\n                    } else {\r\n                        combatLog.noAP(this.name, this.APCost);\r\n                    }\r\n                }\r\n            }\r\n        },\r\n        APCost: 10,\r\n    }\r\n    allAbilities[4] = {\r\n        name: `Guard`,\r\n        effect: function (caster, target) {\r\n            if (!isBuffingEnemies(caster, target)) {\r\n                if (!isTargetDead(target)) {\r\n                    if (!target.buffs.guarded) {\r\n                        if (turn.AP >= this.APCost) {\r\n                            const mods = {\r\n                                abilityIndex: 1,\r\n                                abilityRange: 1,\r\n                                buffNameForTarget: `Guarded`,\r\n                                buffNameForCaster: `Guarding`,\r\n                                buffDescForTarget: `Guarded by ${caster.name}`,\r\n                                buffDescForCaster: `Guarding ${target.name}`,\r\n                            };\r\n                            if(isTargetInRangeOfCaster(caster, target, mods.abilityRange)) {\r\n                                effect.guard(caster, target, mods); turn.AP -= this.APCost\r\n                            } else {\r\n                                combatLog.targetNotInRange(target, this.name);\r\n                            }\r\n                        } else {\r\n                            combatLog.noAP(this.name, this.APCost);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        },\r\n        APCost: 50,\r\n    }\r\n    allAbilities[5] = {\r\n        name: `Leaping Strike`,\r\n        effect: function (caster, target) {\r\n            if (!isAttackingAllies(caster, target)) {\r\n                if (!isTargetDead(target)) {\r\n                    if (turn.AP >= this.APCost) {\r\n                        const mods = {\r\n                            abilityIndex: 0,\r\n                            abilityRange: 2,\r\n                            attackRollDice: 100,\r\n                            attackBonus: caster.stats.dexterity,\r\n                            damageRollDice: {\r\n                                mainHandWeapon: caster.equipment.mainHand.damage,\r\n                                offHandWeapon: caster.equipment.offHand.damage,\r\n                                ability: null,\r\n                            },\r\n                            damageBonus: [0, caster.stats.strength],\r\n                            critThreshold: 100,\r\n                            critMultiplier: 2,\r\n                            defendRollDice: 20,\r\n                            targetParry: Math.floor((target.stats.initiative / 2) + (target.stats.dexterity / 4) + target.parry),\r\n                            targetDodge: Math.floor((target.stats.initiative / 2) + (target.stats.agility / 4) + target.dodge),\r\n                            targetDisrupt: Math.floor((target.stats.initiative / 2) + (target.stats.willpower / 4) + target.disrupt),\r\n                            targetBlock: Math.floor((target.stats.initiative / 2) + target.block),\r\n                            getDefendBonus: function () {\r\n                                return Math.max(this.targetParry, this.targetBlock)\r\n                            },\r\n                        };\r\n                        if(isTargetInRangeOfCaster(caster, target, mods.abilityRange)) {\r\n                            effect.meleeAttack(caster, target, mods); turn.AP -= this.APCost\r\n                        } else {\r\n                            combatLog.targetNotInRange(target, this.name);\r\n                        }\r\n                    } else {\r\n                        combatLog.noAP(this.name, this.APCost);\r\n                    }\r\n                }\r\n            }\r\n        },\r\n        APCost: 20,\r\n    }\r\n    allAbilities[6] = {\r\n        name: `Reflexive Focus`, // TODO: Make this ability drain 5 ap every turn that it is active, also need a way to see that it is active and a way to disable it.\r\n        effect: function (caster, target) {\r\n            if (!caster.buffs.reflexiveFocus) {\r\n                if (turn.AP >= this.APCost) {\r\n                    const mods = {\r\n                        name: `Reflexive Focus`,\r\n                        desc: `${caster.name} is focused on his defenses, giving advantage on defense rolls. `,\r\n                        buffNameForBuffObj: `reflexiveFocus`,\r\n                        defendRollAdvantage: 1,\r\n                    };\r\n                    effect.casterOnlyBuff(caster, mods); turn.AP -= this.APCost\r\n                } else {\r\n                    combatLog.noAP(this.name, this.APCost);\r\n                }\r\n            } else {\r\n                // TODO: Need a combat log for the target\r\n            }\r\n        },\r\n        APCost: 5,\r\n    }\r\n    allAbilities[7] = {\r\n        name: `Reveal Weakness`,\r\n        effect: function (caster, target) {\r\n            if (!isAttackingAllies(caster, target)) {\r\n                if (!isTargetDead(target)) {\r\n                    if (turn.AP >= this.APCost) {\r\n                        const mods = {\r\n                            name: `Reveal Weakness`,\r\n                            desc: `${caster.name} has revealed ${target.name}'s weakness, giving him disadvantage on defense, and he takes 1 extra damage from all attacks. `,\r\n                            debuffNameForBuffObj: `revealWeakness`,\r\n                            defendRollAdvantage: -1,\r\n                            abilityRange: 5,\r\n                        };\r\n                        if(isTargetInRangeOfCaster(caster, target, mods.abilityRange)) {\r\n                            effect.debuff(caster, target, mods); turn.AP -= this.APCost\r\n                        } else {\r\n                            combatLog.targetNotInRange(target, this.name);\r\n                        }\r\n                    } else {\r\n                        combatLog.noAP(this.name, this.APCost);\r\n                    }\r\n                }\r\n            }\r\n        },\r\n        APCost: 75,\r\n    }\r\n    allAbilities[8] = {\r\n        name: `Flesh Eating`,\r\n        effect: function (caster, target) {\r\n            if (!isAttackingAllies(caster, target)) {\r\n                if (turn.AP >= this.APCost) {\r\n                    effect.attack(caster, target); turn.AP -= this.APCost\r\n                } else {\r\n                    combatLog.noAP(this.name, this.APCost);\r\n                }\r\n            }\r\n        },\r\n        APCost: 25,\r\n    }\r\n    allAbilities[9] = {\r\n        name: `Riposte`,\r\n        effect: function (caster, target) {\r\n            if (!isAttackingAllies(caster, target)) {\r\n                if (!isTargetDead(target)) {\r\n                    const mods = {\r\n                        isRiposte: true,\r\n                        abilityIndex: 9,\r\n                        attackRollDice: 100,\r\n                        attackBonus: caster.stats.dexterity,\r\n                        damageRollDice: {\r\n                            mainHandWeapon: caster.equipment.mainHand.damage,\r\n                            offHandWeapon: caster.equipment.offHand.damage,\r\n                            ability: null,\r\n                        },\r\n                        damageBonus: [0, caster.stats.strength],\r\n                        critThreshold: 100,\r\n                        critMultiplier: 2,\r\n                        defendRollDice: 20,\r\n                        targetParry: Math.floor((target.stats.initiative / 2) + (target.stats.dexterity / 4) + target.parry),\r\n                        targetDodge: Math.floor((target.stats.initiative / 2) + (target.stats.agility / 4) + target.dodge),\r\n                        targetDisrupt: Math.floor((target.stats.initiative / 2) + (target.stats.willpower / 4) + target.disrupt),\r\n                        targetBlock: Math.floor((target.stats.initiative / 2) + target.block),\r\n                        getDefendBonus: function () {\r\n                            return Math.max(this.targetParry, this.targetBlock)\r\n                        },\r\n                    };\r\n                    effect.meleeAttack(caster, target, mods); turn.AP -= this.APCost\r\n                }\r\n            }\r\n        },\r\n        APCost: 0,\r\n    }\r\n}\r\n\r\nconst allWeapons = [];\r\nfunction defineAllWeapons() {\r\n    allWeapons[0] = {\r\n        name: `Unarmed`,\r\n        type: `melee`,\r\n        damage: [[0, 1, 4]],\r\n        range: 1,\r\n        parry: 0,\r\n        dodge: 0,\r\n        disrupt: 0,\r\n        block: 0,\r\n    }\r\n    allWeapons[1] = {\r\n        name: `Dagger`,\r\n        type: `melee`,\r\n        damage: [[0, 2, 4]],\r\n        range: 1,\r\n        parry: 1,\r\n        dodge: 0,\r\n        disrupt: 0,\r\n        block: 0,\r\n    }\r\n}\r\n\r\nconst allArmors = [];\r\nfunction defineAllArmors() {\r\n    allArmors[0] = {\r\n        name: `None`,\r\n        parry: 0,\r\n        dodge: 0,\r\n        disrupt: 0,\r\n        block: 0,\r\n    }\r\n    allArmors[1] = {\r\n        name: `Chainmail`,\r\n        parry: 1,\r\n        dodge: 0,\r\n        disrupt: 0,\r\n        block: 0,\r\n    }\r\n}\r\n\r\nconst allRaces = [];\r\nfunction defineAllRaces() {\r\n    allRaces[0] = {\r\n        name: `Man`,\r\n        stats: {\r\n            strength: 0,\r\n            dexterity: 0,\r\n            willpower: 0,\r\n            vitality: 0,\r\n            agility: 0,\r\n            initiative: 0,\r\n            intelligence: 4,\r\n            charisma: 0,\r\n        },\r\n        resists: {\r\n            flat: 0,\r\n            piercing: 0,\r\n            ice: -5,\r\n            fire: -5,\r\n            corrosive: -5,\r\n            poison: -5,\r\n            spiritual: -5,\r\n            lighting: -5,\r\n            arcane: -5,\r\n        },\r\n        resistsArray: [0,0,-5,-5,-5,-5,-5,-5,-5],   \r\n    };\r\n    allRaces[1] = {\r\n        name: `Elf`,\r\n        stats: {\r\n            strength: -2,\r\n            dexterity: 2,\r\n            willpower: 0,\r\n            vitality: -4,\r\n            agility: 0,\r\n            initiative: 0,\r\n            intelligence: 8,\r\n            charisma: 0,\r\n        },\r\n        resists: {\r\n            flat: 0,\r\n            piercing: 0,\r\n            ice: -5,\r\n            fire: -5,\r\n            corrosive: -5,\r\n            poison: -5,\r\n            spiritual: -5,\r\n            lighting: -5,\r\n            arcane: -5,\r\n        },\r\n        resistsArray: [0,0,-5,-5,-5,-5,-5,-5,-5],   \r\n    };\r\n    allRaces[2] = {\r\n        name: `Dwarf`,\r\n        stats: {\r\n            strength: 2,\r\n            dexterity: 0,\r\n            willpower: 2,\r\n            vitality: 4,\r\n            agility: -8,\r\n            initiative: 0,\r\n            intelligence: 4,\r\n            charisma: 0,\r\n        },\r\n        resists: {\r\n            flat: 0,\r\n            piercing: 0,\r\n            ice: -3,\r\n            fire: -3,\r\n            corrosive: -3,\r\n            poison: -3,\r\n            spiritual: -3,\r\n            lighting: -3,\r\n            arcane: -3,\r\n        },\r\n        resistsArray: [0,0,-3,-3,-3,-3,-3,-3,-3],   \r\n\r\n    };\r\n    allRaces[3] = {\r\n        name: `Saurus`,\r\n        stats: {\r\n            strength: 14,\r\n            dexterity: -2,\r\n            willpower: 4,\r\n            vitality: 14,\r\n            agility: 2,\r\n            initiative: 4,\r\n            intelligence: -14,\r\n            charisma: -18,\r\n        },\r\n        resists: {\r\n            flat: 5,\r\n            piercing: 5,\r\n            ice: 0,\r\n            fire: 0,\r\n            corrosive: 0,\r\n            poison: 0,\r\n            spiritual: -5,\r\n            lighting: 0,\r\n            arcane: -5,\r\n        },\r\n        resistsArray: [5,5,0,0,0,0,-5,0,-5],   \r\n    };\r\n}\r\n\r\nconst allTalents = [];\r\nfunction defineAllTalents() {\r\n    allTalents[0] = {\r\n        name: `Strong`,\r\n        statBonusName: `strength`,\r\n        statBonusAmount: 4,\r\n        ability: 1,\r\n    };\r\n    allTalents[1] = {\r\n        name: `Dexterous`,\r\n        statBonusName: `dexterity`,\r\n        statBonusAmount: 4,\r\n        ability: 2,\r\n    };\r\n    allTalents[2] = {\r\n        name: `Soulful`,\r\n        statBonusName: `willpower`,\r\n        statBonusAmount: 4,\r\n        ability: 3,\r\n    };\r\n    allTalents[3] = {\r\n        name: `Resilient`,\r\n        statBonusName: `vitality`,\r\n        statBonusAmount: 4,\r\n        ability: 4,\r\n    };\r\n    allTalents[4] = {\r\n        name: `Agile`,\r\n        statBonusName: `agility`,\r\n        statBonusAmount: 4,\r\n        ability: 5,\r\n    };\r\n    allTalents[5] = {\r\n        name: `Responsive`,\r\n        statBonusName: `initiative`,\r\n        statBonusAmount: 4,\r\n        ability: 6,\r\n    };\r\n    allTalents[6] = {\r\n        name: `Genius`,\r\n        statBonusName: `intelligence`,\r\n        statBonusAmount: 4,\r\n        ability: 7,\r\n    };\r\n    allTalents[7] = {\r\n        name: `Charismatic`,\r\n        statBonusName: `charisma`,\r\n        statBonusAmount: 4,\r\n        ability: 8,\r\n    };\r\n    allTalents[8] = {\r\n        name: `Sorcerous`,\r\n    };\r\n}\r\n\r\nconst allFeats = [];\r\nfunction defineAllFeats() {\r\n    allFeats[0] = {\r\n        name: `Brute Force`,\r\n        parry: 0,\r\n        dodge: 0,\r\n        disrupt: 0,\r\n        block: 0,\r\n    }\r\n    allFeats[1] = {\r\n        name: `Heavy Strikes`,\r\n        parry: 1,\r\n        dodge: 0,\r\n        disrupt: 0,\r\n        block: 0,\r\n    }\r\n}\r\n\r\nconst allBackgrounds = [];\r\nfunction defineAllBackgrounds() {\r\n    allBackgrounds[0] = {\r\n        name: `Peasant`,\r\n        parry: 0,\r\n        dodge: 0,\r\n        disrupt: 0,\r\n        block: 0,\r\n    }\r\n    allBackgrounds[1] = {\r\n        name: `Mercenary`,\r\n        parry: 1,\r\n        dodge: 0,\r\n        disrupt: 0,\r\n        block: 0,\r\n    }\r\n}\r\n\r\n/* #endregion All Lists*/\r\n\r\n/* #region  Groups */\r\n\r\n// Index 0 is always the main/player character\r\n\r\nconst PCs = {\r\n    name: `PC`,\r\n    charList: [],\r\n}\r\n\r\nconst NPCs = {\r\n    name: `NPC`,\r\n    charList: [],\r\n}\r\n\r\nconst unassignedGroup = {\r\n    name: `Unassigned`,\r\n    charList: [],\r\n}\r\n\r\n/* #endregion Groups */\r\n\r\n/* #region  Char Creation */\r\n\r\nfunction Char(name, race) {\r\n    this.name = `${name}`;\r\n    this.groupName = ``;\r\n    this.raceName = `${race.name}`;\r\n    this.talent1Name = ``;\r\n    this.talent2Name = ``;\r\n    this.hp = 100;\r\n    this.abilities = [0];\r\n    this.stats = race.stats;\r\n    this.resists = race.resists;\r\n    this.resistsArray = race.resistsArray; \r\n    this.buffs = {};\r\n    this.debuffs = {};\r\n    this.row = 1;\r\n    this.equipment = {\r\n        mainHand: allWeapons[0],\r\n        offHand: allWeapons[0],\r\n        armor: allArmors[0],\r\n    };\r\n    this.addEquipment = function (slotName, equipment) {\r\n        this.equipment[slotName] = equipment;\r\n        this.parry = sumOfArray([this.equipment.mainHand.parry, this.equipment.offHand.parry, this.equipment.armor.parry]);\r\n        this.dodge = sumOfArray([this.equipment.mainHand.dodge, this.equipment.offHand.dodge, this.equipment.armor.dodge]);\r\n        this.disrupt = sumOfArray([this.equipment.mainHand.disrupt, this.equipment.offHand.disrupt, this.equipment.armor.disrupt]);\r\n        this.block = sumOfArray([this.equipment.mainHand.block, this.equipment.offHand.block, this.equipment.armor.block]);\r\n    };\r\n    this.addStatBonus = function (statName, amount) {\r\n        switch (statName) {\r\n            case `strength`:\r\n                this.stats.strength += amount;\r\n                break;\r\n            case `dexterity`:\r\n                this.stats.dexterity += amount;\r\n                break;\r\n            case `willpower`:\r\n                this.stats.willpower += amount;\r\n                break;\r\n            case `vitality`:\r\n                this.stats.vitality += amount;\r\n                break;\r\n            case `agility`:\r\n                this.stats.agility += amount;\r\n                break;\r\n            case `initiative`:\r\n                this.stats.initiative += amount;\r\n                break;\r\n            case `intelligence`:\r\n                this.stats.intelligence += amount;\r\n                break;\r\n            case `charisma`:\r\n                this.stats.charisma += amount;\r\n                break;\r\n        }\r\n    };\r\n    this.useAbility = function (abilityIndex, target) {\r\n        if (this.hp > 0) {\r\n            if (this.abilities.includes(+abilityIndex) || +abilityIndex === 9) {\r\n                allAbilities[abilityIndex].effect(this, target);\r\n            } else {\r\n                console.log(`Err: Char does not have this ability`);\r\n            }\r\n        } else {\r\n            combatLog.charIsDead(this, allAbilities[abilityIndex]);\r\n        }\r\n    };\r\n    this.getTalentNames = function () {\r\n        return this.talent1Name + this.talent2Name;\r\n    };\r\n    this.initCharReferenceForChildObjects = function (childObject) {\r\n        this[childObject].char = this;\r\n        delete this.initCharReferenceForChildObjects;\r\n        return this;\r\n    };\r\n    /*     \r\n        this.inventory = {\r\n            hands: [null,null,null,null],\r\n            backpack: false,\r\n            saddlebag: false,\r\n            properties: false,\r\n        };\r\n    */\r\n\r\n};\r\n\r\nfunction characterCreator(name, race, talent1, talent2, group) {\r\n    function createChar(name, race) {\r\n        unassignedGroup.charList.push(new Char(name, race));\r\n    }\r\n    function addTalents(talent1, talent2) {\r\n        // targetChar is always equal to the latest created character in the unnassignedGroup.charList array.\r\n        const targetChar = unassignedGroup.charList[unassignedGroup.charList.length - 1];\r\n        const talent1StatBonusName = talent1.statBonusName;\r\n        const talent1StatBonusAmount = talent1.statBonusAmount;\r\n        const talent2StatBonusName = talent2.statBonusName;\r\n        const talent2StatBonusAmount = talent2.statBonusAmount;\r\n        const talent1Ability = talent1.ability;\r\n        const talent2Ability = talent2.ability;\r\n        targetChar.talent1Name = talent1.name;\r\n        targetChar.talent2Name = talent2.name;\r\n        targetChar.addStatBonus(talent1StatBonusName, talent1StatBonusAmount);\r\n        targetChar.addStatBonus(talent2StatBonusName, talent2StatBonusAmount);\r\n        targetChar.abilities.push(talent1Ability);\r\n        targetChar.abilities.push(talent2Ability);\r\n    }\r\n    function addEquipment() {\r\n        const targetChar = unassignedGroup.charList[unassignedGroup.charList.length - 1];\r\n        targetChar.addEquipment(`armor`, allArmors[0]);\r\n    }\r\n    function assignGroup(group) {\r\n        const targetChar = unassignedGroup.charList[unassignedGroup.charList.length - 1];\r\n        targetChar.groupName = group.name;\r\n        group.charList.push(targetChar);\r\n        unassignedGroup.charList.pop();\r\n    }\r\n    createChar(name, race);\r\n    addTalents(talent1, talent2);\r\n    addEquipment();\r\n    assignGroup(group);\r\n};\r\n\r\n/* #endregion Char Creation*/\r\n\r\n/* #region  DOM */\r\n\r\nconst DOM = {\r\n    moveRowButtons: document.querySelector(`.moveRowButtons`),\r\n    equipmentList: document.querySelector(`.equipmentList`),\r\n    endTurnButton: document.querySelector(`.endTurnButton`),\r\n    APCount: document.querySelector(`.APCount`),\r\n    casterSelectionDisplay: document.querySelector(`.casterSelectionDisplay`),\r\n    targetSelectionDisplay: document.querySelector(`.targetSelectionDisplay`),\r\n    PCBar: document.querySelector(`.PCBar`),\r\n    PCBarRow1: document.querySelector(`.PCBarRow1`),\r\n    PCBarRow2: document.querySelector(`.PCBarRow2`),\r\n    PCBarRow3: document.querySelector(`.PCBarRow3`),\r\n    NPCBarRow1: document.querySelector(`.NPCBarRow1`),\r\n    NPCBarRow2: document.querySelector(`.NPCBarRow2`),\r\n    NPCBarRow3: document.querySelector(`.NPCBarRow3`),\r\n    NPCBar: document.querySelector(`.NPCBar`),\r\n    abilityListContainer: document.querySelector(`.abilityListContainer`),\r\n    botBar: document.querySelector(`.botBar`),\r\n    midBar: document.querySelector(`.midBar`),\r\n    casterSelection: null,\r\n    targetSelection: null,\r\n    casterSelectionState: null,\r\n    targetSelectionState: null,\r\n\r\n    listenForEndTurnButton: function () {\r\n        this.endTurnButton.addEventListener(`click`, (e) => {\r\n            turn.end();\r\n        })\r\n    },\r\n\r\n    listenForMoveRowButtons: function () {\r\n        this.moveRowButtons.addEventListener(`click`, (e) => {\r\n            if(e.target.className === `up` && this.casterSelectionState !== null) {\r\n                if(this.casterSelectionState.row > 1) {\r\n                    this.casterSelectionState.row -= 1;\r\n                }\r\n            }\r\n            if(e.target.className === `down` && this.casterSelectionState !== null) {\r\n                if(this.casterSelectionState.row < 3) {\r\n                    this.casterSelectionState.row += 1;\r\n                }\r\n            }\r\n            this.update();\r\n        })\r\n    },\r\n\r\n    attemptAbilityCast: function (target) {\r\n        const abilityNameSubDiv = target.querySelector(`.abilityName`);\r\n        const abilityDatasetIndex = abilityNameSubDiv.dataset.abilityIndex;\r\n        if ((this.casterSelectionState && this.targetSelectionState) !== null) {\r\n            this.casterSelectionState.useAbility(abilityDatasetIndex, this.targetSelectionState)\r\n        } else {\r\n            console.log(`invalid targets`);\r\n        }\r\n        this.update();\r\n        this.updateTopBar();\r\n    },\r\n\r\n    listenForBotBar: function () {\r\n        this.botBar.addEventListener(`click`, (e) => {\r\n            switch (e.target.className) {\r\n                case `ability`:\r\n                    this.attemptAbilityCast(e.target);\r\n                    break;\r\n                case `slideLeft`:\r\n\r\n                    break;\r\n                case `slideRight`:\r\n\r\n                    break;\r\n            }\r\n        })\r\n    },\r\n\r\n    updateTopBar: function () {\r\n        if (this.casterSelectionState) {\r\n            this.casterSelectionDisplay.textContent = `Caster: ${this.casterSelectionState.name}`;\r\n        } else {\r\n            this.casterSelectionDisplay.textContent = `Caster: None Selected`;\r\n        }\r\n\r\n        if (this.targetSelectionState) {\r\n            this.targetSelectionDisplay.textContent = `Target: ${this.targetSelectionState.name}`;\r\n        } else {\r\n            this.targetSelectionDisplay.textContent = `Target: None Selected`;\r\n        }\r\n        this.APCount.textContent = `Action Points: ${turn.AP}`;\r\n    },\r\n\r\n    updateBotBar: function (selectedPC) {\r\n        if (selectedPC && !this.abilityListContainer.hasChildNodes()) {\r\n            selectedPC.abilities.forEach((element) => this.createAbility(element));\r\n        } else if (!selectedPC) {\r\n            this.abilityListContainer.innerHTML = ``;\r\n        }\r\n    },\r\n\r\n    createAbility: function (abilityIndex) {\r\n        const i = document.createElement(`div`);\r\n        i.className = `ability`;\r\n        i.innerHTML = `<div data-ability-index=${abilityIndex} class=\"abilityName\">${allAbilities[abilityIndex].name}</div>`;\r\n        this.abilityListContainer.append(i);\r\n    },\r\n\r\n    selectCaster: function (target) {\r\n        if (this.casterSelection !== null && target !== this.casterSelection) {\r\n            this.deselectCaster();\r\n        }\r\n        const targetGroupIndex = target.dataset.groupIndex;\r\n        this.casterSelectionState = PCs.charList[targetGroupIndex];\r\n        this.casterSelection = target;\r\n        if (this.casterSelectionState.hp === 0) {\r\n            this.casterSelection.style.borderColor = `rgb(75,75,150)`;\r\n        } else {\r\n            this.casterSelection.style.borderColor = `blue`;\r\n        }\r\n        this.updateBotBar();\r\n        this.updateEquipmentList();\r\n    },\r\n\r\n    deselectCaster: function () {\r\n        if (this.casterSelection) {\r\n            if (this.casterSelection === this.targetSelection) {\r\n                this.targetSelection.style.borderColor = `yellow`;\r\n                this.casterSelection = null;\r\n                this.casterSelectionState = null;\r\n            } else {\r\n                if (this.casterSelectionState.hp === 0) {\r\n                    this.casterSelection.style.borderColor = `rgb(50,50,50)`;\r\n                } else {\r\n                    this.casterSelection.style.borderColor = `white`;\r\n                }\r\n                this.casterSelection = null;\r\n                this.casterSelectionState = null;\r\n            }\r\n        }\r\n\r\n        // if(this.casterSelection) {\r\n        //    if(this.casterSelectionState.hp === 0) {\r\n        //         this.casterSelection.style.borderColor = `rgb(50,50,50)`;\r\n        //    } else {\r\n        //         this.casterSelection.style.borderColor = `white`;\r\n        //    }\r\n        //    this.casterSelection = null;\r\n        //    this.casterSelectionState = null;\r\n        // }\r\n        this.updateBotBar();\r\n        this.updateEquipmentList();\r\n    },\r\n\r\n    listenForCasterSelection: function () {\r\n        this.PCBar.addEventListener(`click`, (e) => {\r\n            if (e.target.className === `PC`) {\r\n                this.selectCaster(e.target);\r\n            } else {\r\n                this.deselectCaster();\r\n            }\r\n            this.updateTopBar();\r\n            this.updateBotBar(this.casterSelectionState);\r\n        })\r\n    },\r\n\r\n    listenForTargetSelection: function () {\r\n        this.midBar.addEventListener(`contextmenu`, (e) => {\r\n            e.preventDefault();\r\n            if (e.target.className === `PC` || e.target.className === `NPC`) {\r\n                this.selectTarget(e.target);\r\n            } else {\r\n                this.deselectTarget();\r\n            }\r\n            this.updateTopBar();\r\n        })\r\n    },\r\n\r\n    selectTarget: function (target) {\r\n        if (this.targetSelection !== null && target !== this.targetSelection) {\r\n            this.deselectTarget();\r\n        }\r\n        this.targetSelection = target;\r\n        let targetGroup = target.className;\r\n        const targetGroupIndex = target.dataset.groupIndex;\r\n        if (targetGroup === `NPC`) {\r\n            this.targetSelectionState = NPCs.charList[targetGroupIndex];\r\n            target.style.borderColor = `red`;\r\n        };\r\n        if (targetGroup === `PC`) {\r\n            this.targetSelectionState = PCs.charList[targetGroupIndex];\r\n            target.style.borderColor = `yellow`;\r\n        }\r\n    },\r\n\r\n    deselectTarget: function () {\r\n        if (this.targetSelection) {\r\n            if (this.targetSelection === this.casterSelection) {\r\n                if (this.targetSelectionState.hp === 0) {\r\n                    this.targetSelection.style.borderColor = `rgb(75,75,150)`;\r\n                } else {\r\n                    this.targetSelection.style.borderColor = `blue`;\r\n                }\r\n                this.targetSelection = null;\r\n                this.targetSelectionState = null;\r\n            } else {\r\n                if (this.targetSelectionState.hp === 0) {\r\n                    this.targetSelection.style.borderColor = `rgb(50,50,50)`;\r\n                } else {\r\n                    this.targetSelection.style.borderColor = `white`;\r\n                }\r\n                this.targetSelection = null;\r\n                this.targetSelectionState = null;\r\n            }\r\n        }\r\n    },\r\n\r\n    update: function () {\r\n        this.NPCBarRow3.innerHTML = ``;\r\n        this.NPCBarRow2.innerHTML = ``;\r\n        this.NPCBarRow1.innerHTML = ``;\r\n        this.PCBarRow1.innerHTML = ``;\r\n        this.PCBarRow2.innerHTML = ``;\r\n        this.PCBarRow3.innerHTML = ``;\r\n        for (let i = (PCs.charList.length - 1); i >= 0; i--) {\r\n            this.createChar(PCs.charList[i], i)\r\n        };\r\n        for (let i = (NPCs.charList.length - 1); i >= 0; i--) {\r\n            this.createChar(NPCs.charList[i], i)\r\n        };\r\n    },\r\n\r\n    updateEquipmentList: function () {\r\n        this.equipmentList.innerHTML = `Equipment:`;\r\n        if (this.casterSelectionState) {\r\n            for (let i = 0; i <= (Object.keys(this.casterSelectionState.equipment).length - 1); i++) {\r\n                this.createEquipmentDisplay(this.casterSelectionState, i)\r\n            };\r\n        }\r\n    },\r\n\r\n    createChar: function (char, charListIndex) {\r\n        const i = document.createElement(`div`);\r\n        i.className = `${char.groupName}`;\r\n        i.id = `index${charListIndex}`;\r\n        i.dataset.groupIndex = charListIndex;\r\n        forceHPtoZero(char);\r\n        if (char.hp === 0) {\r\n            i.style.borderColor = `rgb(50,50,50)`;\r\n            i.innerHTML = `<div class=\"name\">${char.name}</div>\r\n                           <div class=\"HP\">HP: ${char.hp} (Dead)</div>\r\n                           <div class=\"race\">Race: ${char.raceName}</div>\r\n                           <div class=\"talents\">Talents: ${char.talent1Name} & ${char.talent2Name}</div>`;\r\n        } else {\r\n            i.innerHTML = `<div class=\"name\">${char.name}</div>\r\n                           <div class=\"HP\">HP: ${char.hp}</div>\r\n                           <div class=\"race\">Race: ${char.raceName}</div>\r\n                           <div class=\"talents\">Talents: ${char.talent1Name} & ${char.talent2Name}</div>`;\r\n        }\r\n\r\n        switch (char.groupName) {\r\n            case `PC`:\r\n                if (this.casterSelectionState === char) {\r\n                    if (this.casterSelectionState.hp === 0) {\r\n                        i.style.borderColor = `rgb(75,75,150)`;\r\n                    } else {\r\n                        i.style.borderColor = `blue`;\r\n                    }\r\n                    this.casterSelection = i;\r\n                } else if (this.targetSelectionState === char) {\r\n                    i.style.borderColor = `yellow`;\r\n                    this.targetSelection = i;\r\n                }\r\n                this.appendPCCharToRow(char, i);\r\n                break;\r\n\r\n            case `NPC`:\r\n                if (this.targetSelectionState === char) {\r\n                    i.style.borderColor = `red`;\r\n                    this.targetSelection = i;\r\n                }\r\n                this.appendNPCCharToRow(char, i);\r\n                break;\r\n\r\n            case `Unassigned`:\r\n                console.log(`Error: Tried to put char with unassigned group onto DOM.`);\r\n                break;\r\n\r\n            default:\r\n                console.log(`Error: Something weird happened here.`);\r\n                break;\r\n        }\r\n    },\r\n\r\n    createEquipmentDisplay: function (char, keyNumberOfItem) {\r\n        const i = document.createElement(`div`);\r\n        const arrayOfAllKeysInEquipment = Object.keys(char.equipment);\r\n        const itemKeyName = arrayOfAllKeysInEquipment[keyNumberOfItem];\r\n        const item = char.equipment[itemKeyName];\r\n        if (item === null) {\r\n            i.innerHTML = `<div class=\"slotName\">${itemKeyName}: None</div>`;\r\n        } else if (item.damage) {\r\n            i.innerHTML = `<div class=\"slotName\">${itemKeyName}: ${item.name} Damage: ${item.damage[0][0]}D${item.damage[0][1]}</div>`;\r\n        } else {\r\n            i.innerHTML = `<div class=\"slotName\">${itemKeyName}: ${item.name} </div>`;\r\n        }\r\n        this.equipmentList.append(i);\r\n    },\r\n    appendPCCharToRow: function (char, i) {\r\n        switch (char.row) {\r\n            case 1: \r\n                this.PCBarRow1.append(i);\r\n            break;\r\n            case 2: \r\n                this.PCBarRow2.append(i);\r\n            break;\r\n            case 3: \r\n                this.PCBarRow3.append(i);\r\n            break;\r\n        }\r\n    },\r\n    appendNPCCharToRow: function (char, i) {\r\n        switch (char.row) {\r\n            case 1: \r\n                this.NPCBarRow1.append(i);\r\n            break;\r\n            case 2: \r\n                this.NPCBarRow2.append(i);\r\n            break;\r\n            case 3: \r\n                this.NPCBarRow3.append(i);\r\n            break;\r\n        }\r\n    },\r\n};\r\n\r\n/* #endregion DOM*/\r\n\r\ndefineAllAbilities();\r\ndefineAllWeapons();\r\ndefineAllRaces();\r\ndefineAllTalents();\r\ndefineAllArmors();\r\ndefineAllFeats();\r\ndefineAllBackgrounds();\r\n\r\ncharacterCreator(`Stroick`, allRaces[0], allTalents[0], allTalents[5], PCs);\r\ncharacterCreator(`Kliftin`, allRaces[1], allTalents[2], allTalents[6], PCs);\r\ncharacterCreator(`Dahmer Hobo`, allRaces[3], allTalents[6], allTalents[7], NPCs);\r\ncharacterCreator(`Evil`, allRaces[2], allTalents[4], allTalents[5], NPCs);\r\n\r\nconst stroick = PCs.charList[0];\r\nconst evil = NPCs.charList[1];\r\nconst kliftin = PCs.charList[1];\r\nconst hobo = NPCs.charList[0];\r\n\r\nDOM.update();\r\nDOM.listenForCasterSelection();\r\nDOM.listenForBotBar();\r\nDOM.listenForEndTurnButton();\r\nDOM.listenForTargetSelection();\r\nDOM.listenForMoveRowButtons();\r\n\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ }),

/***/ "./src/print.js":
/*!**********************!*\
  !*** ./src/print.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ printMe)\n/* harmony export */ });\nfunction printMe() {\r\n    console.log('I get called from print.js!');\r\n  }\n\n//# sourceURL=webpack:///./src/print.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;