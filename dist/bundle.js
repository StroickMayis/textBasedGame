/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/css-loader/dist/cjs.js!./src/index.css":
/*!*************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/index.css ***!
  \*************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/noSourceMaps.js */ \"./node_modules/css-loader/dist/runtime/noSourceMaps.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `* {\r\n    color: white;\r\n    box-sizing: border-box;\r\n}\r\n\r\nbody {\r\n    background-color: black;\r\n    margin: 0;\r\n    padding: 0;\r\n    display: flex;\r\n    min-height: 100vh;\r\n}\r\n\r\n.gameDivision,\r\n.chatDivision,\r\n.utilDivision {\r\n    border: 1px solid white;\r\n    text-align: center;\r\n    height: 100vh;\r\n}\r\n\r\n.chatDivision,\r\n.utilDivision {\r\n    flex: 1 1 10dvw;\r\n}\r\n\r\n.gameDivision {\r\n    flex: 2.5 2.5 auto;\r\n    display: flex;\r\n    flex-direction: column;\r\n}\r\n\r\n.gameDivision .topBar,\r\n.gameDivision .midBar,\r\n.gameDivision .botBar {\r\n    border: 1px solid white;\r\n}\r\n\r\n.gameDivision .topBar{\r\n    flex: 2 1 auto;\r\n}\r\n\r\n.gameDivision .midBar{\r\n    flex: 90 1 10dvh;\r\n    display: flex;\r\n    flex-direction: column;\r\n}\r\n\r\n.gameDivision .botBar{\r\n    flex: 10 1 auto;\r\n}\r\n\r\n.NPCBar {\r\n    border: 1px solid white;\r\n    flex: 1 1 auto;\r\n    flex-direction: column;\r\n    display: flex;\r\n    justify-content: space-around;\r\n    align-items: center;\r\n}\r\n\r\n.PCBar {\r\n    border: 1px solid white;\r\n    flex: 1 1 auto;\r\n    display: flex;\r\n    flex-direction: column;\r\n    justify-content: space-around;\r\n    align-items: center;\r\n}\r\n\r\n.NPC {\r\n    border: 1px solid white;\r\n    width: 125px;\r\n    height: 125px;\r\n}\r\n\r\n.PC {\r\n    border: 1px solid white;\r\n    width: 125px;\r\n    height: 125px;\r\n}\r\n\r\n.ability {\r\n    border: 1px solid white;\r\n    flex: 1 1 auto;\r\n}\r\n\r\n.slideLeft,\r\n.slideRight {\r\n    border: 1px solid white;\r\n    flex: .025 1 auto;\r\n}\r\n\r\n.botBar {\r\n    display: flex;\r\n    justify-content: space-evenly;\r\n}\r\n\r\n.abilityListContainer {\r\n    display: flex;\r\n    flex: 1 1 auto;\r\n}\r\n\r\n.utilDivision {\r\n    display: flex;\r\n    flex-direction: column;\r\n    justify-content: space-between;\r\n}\r\n\r\n.endTurnButton {\r\n    border: 1px solid white;\r\n    flex: .09 1 auto;\r\n    text-align: center;\r\n    display: flex;\r\n    justify-content: center;\r\n    align-items: center;\r\n}\r\n\r\n.topBar {\r\n    display: flex;\r\n    justify-content: space-betweens;\r\n}\r\n\r\n.topBar div {\r\n    flex: 1 1 auto;\r\n}\r\n\r\n.PCBarRow1, \r\n.PCBarRow2, \r\n.PCBarRow3,\r\n.NPCBarRow1,\r\n.NPCBarRow2,\r\n.NPCBarRow3\r\n {\r\n    align-items: center;\r\n    justify-content: space-around;\r\n    display: flex;\r\n    width: 100%;\r\n    flex: 1 1 125px;\r\n    border: 1px solid white;\r\n}\r\n\r\n.divider {\r\n    padding: 15px;\r\n}\r\n\r\n.chatDivision {\r\n    display: flex;\r\n    flex-direction: column;\r\n    justify-content: space-between;\r\n}\r\n\r\n.moveRowButtons {\r\n    border: 1px solid white;\r\n    flex: .09 1 auto;\r\n    text-align: center;\r\n    display: flex;\r\n    justify-content: center;\r\n    align-items: center;\r\n}\r\n\r\n.moveRowButtons div{\r\n    border: 1px solid white;\r\n    flex: 1 1 auto;\r\n    height: 100%;\r\n    display: flex;\r\n    justify-content: center;\r\n    align-items: center;\r\n}`, \"\"]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack:///./src/index.css?./node_modules/css-loader/dist/cjs.js");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = [];\n\n  // return the list of modules as css string\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = \"\";\n      var needLayer = typeof item[5] !== \"undefined\";\n      if (item[4]) {\n        content += \"@supports (\".concat(item[4], \") {\");\n      }\n      if (item[2]) {\n        content += \"@media \".concat(item[2], \" {\");\n      }\n      if (needLayer) {\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\n      }\n      content += cssWithMappingToString(item);\n      if (needLayer) {\n        content += \"}\";\n      }\n      if (item[2]) {\n        content += \"}\";\n      }\n      if (item[4]) {\n        content += \"}\";\n      }\n      return content;\n    }).join(\"\");\n  };\n\n  // import a list of modules into the list\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === \"string\") {\n      modules = [[null, modules, undefined]];\n    }\n    var alreadyImportedModules = {};\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n      if (typeof layer !== \"undefined\") {\n        if (typeof item[5] === \"undefined\") {\n          item[5] = layer;\n        } else {\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\n          item[5] = layer;\n        }\n      }\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\n          item[2] = media;\n        }\n      }\n      if (supports) {\n        if (!item[4]) {\n          item[4] = \"\".concat(supports);\n        } else {\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\n          item[4] = supports;\n        }\n      }\n      list.push(item);\n    }\n  };\n  return list;\n};\n\n//# sourceURL=webpack:///./node_modules/css-loader/dist/runtime/api.js?");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/noSourceMaps.js":
/*!**************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/noSourceMaps.js ***!
  \**************************************************************/
/***/ ((module) => {

eval("\n\nmodule.exports = function (i) {\n  return i[1];\n};\n\n//# sourceURL=webpack:///./node_modules/css-loader/dist/runtime/noSourceMaps.js?");

/***/ }),

/***/ "./src/index.css":
/*!***********************!*\
  !*** ./src/index.css ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleDomAPI.js */ \"./node_modules/style-loader/dist/runtime/styleDomAPI.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertBySelector.js */ \"./node_modules/style-loader/dist/runtime/insertBySelector.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ \"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertStyleElement.js */ \"./node_modules/style-loader/dist/runtime/insertStyleElement.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleTagTransform.js */ \"./node_modules/style-loader/dist/runtime/styleTagTransform.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../node_modules/css-loader/dist/cjs.js!./index.css */ \"./node_modules/css-loader/dist/cjs.js!./src/index.css\");\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());\noptions.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());\noptions.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, \"head\");\noptions.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"], options);\n\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"] && _node_modules_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals ? _node_modules_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals : undefined);\n\n\n//# sourceURL=webpack:///./src/index.css?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

eval("\n\nvar stylesInDOM = [];\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n  for (var i = 0; i < stylesInDOM.length; i++) {\n    if (stylesInDOM[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n  return result;\n}\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var indexByIdentifier = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3],\n      supports: item[4],\n      layer: item[5]\n    };\n    if (indexByIdentifier !== -1) {\n      stylesInDOM[indexByIdentifier].references++;\n      stylesInDOM[indexByIdentifier].updater(obj);\n    } else {\n      var updater = addElementStyle(obj, options);\n      options.byIndex = i;\n      stylesInDOM.splice(i, 0, {\n        identifier: identifier,\n        updater: updater,\n        references: 1\n      });\n    }\n    identifiers.push(identifier);\n  }\n  return identifiers;\n}\nfunction addElementStyle(obj, options) {\n  var api = options.domAPI(options);\n  api.update(obj);\n  var updater = function updater(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\n        return;\n      }\n      api.update(obj = newObj);\n    } else {\n      api.remove();\n    }\n  };\n  return updater;\n}\nmodule.exports = function (list, options) {\n  options = options || {};\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDOM[index].references--;\n    }\n    var newLastIdentifiers = modulesToDom(newList, options);\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n      var _index = getIndexByIdentifier(_identifier);\n      if (stylesInDOM[_index].references === 0) {\n        stylesInDOM[_index].updater();\n        stylesInDOM.splice(_index, 1);\n      }\n    }\n    lastIdentifiers = newLastIdentifiers;\n  };\n};\n\n//# sourceURL=webpack:///./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

eval("\n\nvar memo = {};\n\n/* istanbul ignore next  */\nfunction getTarget(target) {\n  if (typeof memo[target] === \"undefined\") {\n    var styleTarget = document.querySelector(target);\n\n    // Special case to return head of iframe instead of iframe itself\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n      try {\n        // This will throw an exception if access to iframe is blocked\n        // due to cross-origin restrictions\n        styleTarget = styleTarget.contentDocument.head;\n      } catch (e) {\n        // istanbul ignore next\n        styleTarget = null;\n      }\n    }\n    memo[target] = styleTarget;\n  }\n  return memo[target];\n}\n\n/* istanbul ignore next  */\nfunction insertBySelector(insert, style) {\n  var target = getTarget(insert);\n  if (!target) {\n    throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n  }\n  target.appendChild(style);\n}\nmodule.exports = insertBySelector;\n\n//# sourceURL=webpack:///./node_modules/style-loader/dist/runtime/insertBySelector.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

eval("\n\n/* istanbul ignore next  */\nfunction insertStyleElement(options) {\n  var element = document.createElement(\"style\");\n  options.setAttributes(element, options.attributes);\n  options.insert(element, options.options);\n  return element;\n}\nmodule.exports = insertStyleElement;\n\n//# sourceURL=webpack:///./node_modules/style-loader/dist/runtime/insertStyleElement.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n/* istanbul ignore next  */\nfunction setAttributesWithoutAttributes(styleElement) {\n  var nonce =  true ? __webpack_require__.nc : 0;\n  if (nonce) {\n    styleElement.setAttribute(\"nonce\", nonce);\n  }\n}\nmodule.exports = setAttributesWithoutAttributes;\n\n//# sourceURL=webpack:///./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

eval("\n\n/* istanbul ignore next  */\nfunction apply(styleElement, options, obj) {\n  var css = \"\";\n  if (obj.supports) {\n    css += \"@supports (\".concat(obj.supports, \") {\");\n  }\n  if (obj.media) {\n    css += \"@media \".concat(obj.media, \" {\");\n  }\n  var needLayer = typeof obj.layer !== \"undefined\";\n  if (needLayer) {\n    css += \"@layer\".concat(obj.layer.length > 0 ? \" \".concat(obj.layer) : \"\", \" {\");\n  }\n  css += obj.css;\n  if (needLayer) {\n    css += \"}\";\n  }\n  if (obj.media) {\n    css += \"}\";\n  }\n  if (obj.supports) {\n    css += \"}\";\n  }\n  var sourceMap = obj.sourceMap;\n  if (sourceMap && typeof btoa !== \"undefined\") {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  }\n\n  // For old IE\n  /* istanbul ignore if  */\n  options.styleTagTransform(css, styleElement, options.options);\n}\nfunction removeStyleElement(styleElement) {\n  // istanbul ignore if\n  if (styleElement.parentNode === null) {\n    return false;\n  }\n  styleElement.parentNode.removeChild(styleElement);\n}\n\n/* istanbul ignore next  */\nfunction domAPI(options) {\n  if (typeof document === \"undefined\") {\n    return {\n      update: function update() {},\n      remove: function remove() {}\n    };\n  }\n  var styleElement = options.insertStyleElement(options);\n  return {\n    update: function update(obj) {\n      apply(styleElement, options, obj);\n    },\n    remove: function remove() {\n      removeStyleElement(styleElement);\n    }\n  };\n}\nmodule.exports = domAPI;\n\n//# sourceURL=webpack:///./node_modules/style-loader/dist/runtime/styleDomAPI.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

eval("\n\n/* istanbul ignore next  */\nfunction styleTagTransform(css, styleElement) {\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css;\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild);\n    }\n    styleElement.appendChild(document.createTextNode(css));\n  }\n}\nmodule.exports = styleTagTransform;\n\n//# sourceURL=webpack:///./node_modules/style-loader/dist/runtime/styleTagTransform.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _index_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.css */ \"./src/index.css\");\n \n\n\"use strict\";\n\n/* #region Notes*/\n\n// timeToCast converts to the following:\n// Reaction = 1\n// Bonus Action = 2\n// Action = 3\n// Type of Weapons:\n// Melee = 1\n// Ranged = 2\n// Magic = 3\n// TODO: Must make ID's for everything, to make them easier to handle.\n// TODO: I am copying data too much, all characters should REFERENCE ability data etc, this will make it easier to code and should improve performance.\n\n/* #endregion Notes*/\n\n/* #region  Combat Log */\n\nconst combatLog = {\n    critHit: function (caster, target, damage) {\n        let damageDisplayArray = this.damageDisplay(damage);\n        targetDamageSplit = Math.floor((damageDisplayArray[1] * 2) / 2);\n        guardDamageSplit = Math.ceil((damageDisplayArray[1] * 2) / 2);\n        if (target.buffs.guarded) {\n            console.log(`${caster.name} CRITICALLY HITS ${target.name} and rolls a ${damageDisplayArray[0]} times 2 for a total of ${damageDisplayArray[1] * 2} damage, but because ${target.name} is guarded, the damage is split between him and his guard ${target.buffs.guarded.caster.name}, ${target.name} takes ${targetDamageSplit} and ${target.buffs.guarded.caster.name} takes ${guardDamageSplit}.`);\n        } else {\n            console.log(`${caster.name} CRITICALLY HITS ${target.name} and rolls a ${damageDisplayArray[0]} times 2 for a total of ${damageDisplayArray[1] * 2} damage!`)\n        }\n    },\n    attackAttempt: function (caster, target, attackRoll, defendRoll, attackBonus, defendBonus, ability) {\n        const attack = attackRoll + attackBonus;\n        const defend = defendRoll + defendBonus;\n        console.log(`${caster.name} attacks ${target.name} with: ${caster.equipment.mainHand.name} using: ${ability.name}, \n            with an attack roll of: ${attackRoll} and attack bonus of ${attackBonus} \n            against a defend roll of ${defendRoll} and a defend bonus of ${defendBonus}. \n            Total Attack: ${attack} vs. Total Defend: ${defend}`);\n    },\n    damageDisplay: function (damage) {\n        let damageRollDisplay = [];\n        damageRollDisplay[0] = ``;\n        if (sumOfArray(damage) < 1) {\n            damageRollDisplay[1] = 1;\n        } else {\n            damageRollDisplay[1] = sumOfArray(damage);\n        }\n        let damageBonus = popArrayPopValue(damage);\n        let damageCopy = popArrayArrayValue(damage);\n        for (let i = 0; i < damageCopy.length; i++) {\n            damageRollDisplay[0] += `${damageCopy[i]} + `\n        }\n        damageRollDisplay[0] += `a ${damageBonus} bonus`;\n\n        return damageRollDisplay;\n    },\n    hit: function (caster, target, damage) {\n        let damageDisplayArray = this.damageDisplay(damage); // * damageDisplayArray is an array with the index[0]\n        let targetDamageSplit = Math.floor((damageDisplayArray[1]) / 2);\n        let guardDamageSplit = Math.ceil((damageDisplayArray[1]) / 2);\n        if (target.buffs.guarded) {\n            console.log(`${caster.name} hits ${target.name} and rolls a ${damageDisplayArray[0]} for a total of ${damageDisplayArray[1]} damage, but because ${target.name} is guarded, the damage is split between him and his guard ${target.buffs.guarded.caster.name}, ${target.name} takes ${targetDamageSplit} and ${target.buffs.guarded.caster.name} will take ${guardDamageSplit} but has a chance to defend it.`);\n        } else {\n            console.log(`${caster.name} hits ${target.name} and rolls a ${damageDisplayArray[0]} for a total of ${damageDisplayArray[1]} damage.`);\n        }\n\n    },\n    hitBackupCopy: function (caster, target, damage) {\n        let damageDisplayArray = this.damageDisplay(damage); // * damageDisplayArray is an array with the index[0]\n        let targetDamageSplit = Math.floor((damageDisplayArray[1]) / 2);\n        let guardDamageSplit = Math.ceil((damageDisplayArray[1]) / 2);\n        if (target.buffs.guarded) {\n            console.log(`${caster.name} hits ${target.name} and rolls a ${damageDisplayArray[0]} for a total of ${damageDisplayArray[1]} damage, but because ${target.name} is guarded, the damage is split between him and his guard ${target.buffs.guarded.caster.name}, ${target.name} takes ${targetDamageSplit} and ${target.buffs.guarded.caster.name} will take ${guardDamageSplit} but has a chance to defend it.`);\n        } else {\n            console.log(`${caster.name} hits ${target.name} and rolls a ${damageDisplayArray[0]} for a total of ${damageDisplayArray[1]} damage.`);\n        }\n\n    },\n    defend: function (caster, target) {\n        console.log(`${target.name} defends ${caster.name}'s attack!`);\n    },\n    guardDefend: function (caster, target, guard) {\n        console.log(`${guard.name} defends the incoming damage from ${caster.name} redirected to him from his guard target ${target}!`)\n    },\n    guardFailsDefend: function (caster, target, guard) {\n        console.log(`${guard.name} does not defend the incoming damage from ${caster.name} redirected to him from his guard target ${target.name}, ${guard.name} takes the damage.`)\n    },\n    critHeal: function (caster, target, healAmountRoll, healBonus, healAmount) {\n        console.log(`${caster.name} CRITICALLY HEALS ${target.name} and rolls a ${healAmountRoll} with a ${healBonus} bonus times 2 for a total of ${healAmount} healing!`)\n    },\n    healAttempt: function (caster, target, healRoll, healBonus) {\n        console.log(`${caster.name} attempts to heal ${target.name} with a roll of: ${healRoll}.`)\n    },\n    heal: function (caster, target, healAmountRoll, healBonus, healAmount) {\n        console.log(`${caster.name} heals ${target.name} with a heal roll of ${healAmountRoll} and a ${healBonus} bonus for a total of ${healAmount} healing!`)\n    },\n    healFail: function (caster, target) {\n        console.log(`${caster.name} fails to heal ${target.name}!`)\n    },\n    noAP: function (abilityName, abilityAPCost) {\n        console.log(`Not enough AP to cast ${abilityName}. Total AP: ${turn.AP} - Ability Cost: ${abilityAPCost} `)\n    },\n    charIsDead: function (char, ability) {\n        console.log(`${char.name} cannot cast ${ability.name} while he is dead!`);\n    },\n    guard: function (caster, target) {\n        console.log(`${caster.name} casts his Guard onto ${target.name}.`);\n    },\n    guardSwitch: function (caster, target) {\n        console.log(`${caster.name} switches his Guard from ${caster.buffs.guarding.target.name} to ${target.name}.`);\n    },\n    riposte: function (caster, target) {\n        console.log(`${caster.name} defends well enough to attempt a riposte on ${target.name}.`)\n    },\n    startNPCTurn: function () {\n        console.log(`\n            Start NPC Turn:\n            `);\n    },\n    startPCTurn: function () {\n        console.log(`\n            Start PC Turn:\n            `);\n    },\n    casterOnlyBuff: function (caster, buff) {\n        console.log(`${caster.name} casts ${buff.name} on himself.`);\n    },\n    debuff: function (caster, target, targetDebuff) {\n        console.log(`${caster.name} casts ${targetDebuff.name} onto ${target.name}.`)\n    },\n    targetNotInRange: function (target, abilityName) {\n        console.log(`${target.name} is not in range for ${abilityName} to hit them!`);\n    },\n    damageResist: {\n        0: function (damage, resist, damageSum, caster, target) { //* Takes in the damage and resist number for this specific resistance and logs out the aftermath.\n            console.log(`${caster.name} deals out ${damage} flat damage against ${target.name}'s ${resist} flat resistance. ${target.name} takes ${damageSum} flat damage.`);\n        },\n        1: function (damage, resist, damageSum, caster, target) { //* Takes in the damage and resist number for this specific resistance and logs out the aftermath.\n            console.log(`${caster.name} deals out ${damage} piercing damage against ${target.name}'s ${resist} piercing resistance. ${target.name} takes ${damageSum} piercing damage.`);\n        },\n        2: function (damage, resist, damageSum, caster, target) { //* Takes in the damage and resist number for this specific resistance and logs out the aftermath.\n            console.log(`${caster.name} deals out ${damage} ice damage against ${target.name}'s ${resist} ice resistance. ${target.name} takes ${damageSum} ice damage.`);\n        },\n        3: function (damage, resist, damageSum, caster, target) { //* Takes in the damage and resist number for this specific resistance and logs out the aftermath.\n            console.log(`${caster.name} deals out ${damage} fire damage against ${target.name}'s ${resist} fire resistance. ${target.name} takes ${damageSum} fire damage.`);\n        },\n        4: function (damage, resist, damageSum, caster, target) { //* Takes in the damage and resist number for this specific resistance and logs out the aftermath.\n            console.log(`${caster.name} deals out ${damage} corrosive damage against ${target.name}'s ${resist} corrosive resistance. ${target.name} takes ${damageSum} corrosive damage.`);\n        },\n        5: function (damage, resist, damageSum, caster, target) { //* Takes in the damage and resist number for this specific resistance and logs out the aftermath.\n            console.log(`${caster.name} deals out ${damage} poison damage against ${target.name}'s ${resist} poison resistance. ${target.name} takes ${damageSum} poison damage.`);\n        },\n        6: function (damage, resist, damageSum, caster, target) { //* Takes in the damage and resist number for this specific resistance and logs out the aftermath.\n            console.log(`${caster.name} deals out ${damage} spiritual damage against ${target.name}'s ${resist} spiritual resistance. ${target.name} takes ${damageSum} spiritual damage.`);\n        },\n        7: function (damage, resist, damageSum, caster, target) { //* Takes in the damage and resist number for this specific resistance and logs out the aftermath.\n            console.log(`${caster.name} deals out ${damage} lightning damage against ${target.name}'s ${resist} lightning resistance. ${target.name} takes ${damageSum} lightning damage.`);\n        },\n        8: function (damage, resist, damageSum, caster, target) { //* Takes in the damage and resist number for this specific resistance and logs out the aftermath.\n            console.log(`${caster.name} deals out ${damage} arcane damage against ${target.name}'s ${resist} arcane resistance. ${target.name} takes ${damageSum} arcane damage.`);\n        },\n    }\n}\n\n/* #endregion Combat Log*/\n\n/* #region  Ability Effects & Logic */ \n\nconst turn = {\n    AP: 100,\n    end: function () {\n        combatLog.startNPCTurn();\n        this.AP = 100;\n        while (this.AP > 0) { // TODO: Need to fix this big time.\n            // const attackingNPC = NPCs.charList[dice(NPCs.charList.length - 1)];\n            // attackingNPC.useAbility( attackingNPC.abilities[dice(attackingNPC.abilities.length - 1)] ,PCs.charList[dice(PCs.charList.length - 1)]);\n            const attackingNPC = NPCs.charList[diceMinus1(NPCs.charList.length)];\n            attackingNPC.useAbility(0, PCs.charList[diceMinus1(PCs.charList.length)]);\n        };\n        this.AP = 100;\n        DOM.update();\n        DOM.updateTopBar();\n        combatLog.startPCTurn();\n    },\n}\n\nconst effect = {\n    meleeAttack: function (caster, target, mods) {\n        const ability = allAbilities[mods.abilityIndex];\n        let riposte = false;\n        let damageSum;\n\n        /* #region  CASTER ATTACK */\n        let attackRollAdvantages = calcTargetAttackAdvatages(caster);\n        let attackRoll = rollWithAdvantageCount(100, attackRollAdvantages);\n        const attack = attackRoll + mods.attackBonus;\n        /* #endregion */\n\n        /* #region  TARGET DEFEND */\n        let defendRollAdvantages = calcTargetDefendAdvatages(target);\n        let defendRoll = rollWithAdvantageCount(20, defendRollAdvantages);\n        const defend = defendRoll + mods.getDefendBonus();\n        /* #endregion */\n\n        combatLog.attackAttempt(caster, target, attackRoll, defendRoll, mods.attackBonus, mods.getDefendBonus(), ability);\n\n        /* #region  CHECK & SET RIPOSTE */\n        if (!mods.isRiposte) {\n            if ((Math.ceil(attack / 2)) <= defend) {\n                riposte = true\n            }\n        }\n        /* #endregion */\n\n        /* #region  IF TARGET DEFENDS ATTACK */\n        if (attack <= defend) {\n            combatLog.defend(caster, target);\n            if (riposte) {\n                combatLog.riposte(target, caster);\n                target.useAbility(9, caster);\n            }\n            return;\n        }\n        /* #endregion */\n\n        const damageRollArr = concatRollDice(mods.damageRollDice.mainHandWeapon, mods.damageRollDice.offHandWeapon, mods.damageRollDice.ability);\n        damageRollArr.push(mods.damageBonus);\n        const totalDamagePerResist = sumOfDamageArray(damageRollArr);\n\n        if (attackRoll >= mods.critThreshold) { // * ON CRIT\n            combatLog.critHit(caster, target, damageRollArr);\n\n            if (sumOfArray(damageRollArr) < 1) {\n                target.hp -= 2;\n            } else { // * Resistances and buff and debuff checks all go here\n\n                if (target.buffs.guarded) {\n                    totalDamage = sumOfArray(damageRollArr) * mods.critMultiplier;\n                    targetDamage = Math.floor(totalDamage / 2);\n                    guardDamage = Math.ceil(totalDamage / 2);\n                    target.hp -= targetDamage;\n                    target.buffs.guarded.caster.hp -= guardDamage\n                } else {\n                    target.hp -= sumOfArray(damageRollArr) * mods.critMultiplier;\n                }\n            }\n            return;\n        }\n        console.log(damageRollArr)\n        combatLog.hit(caster, target, damageRollArr); // * ON HIT\n\n        if (riposte) {\n            combatLog.riposte(target, caster);\n            target.useAbility(9, caster);\n        }\n\n        if (target.buffs.guarded) {\n            const guardDefense = getGuardDefense(`melee`, target.buffs.guarded.caster);\n            targetDamage = calcTargetWithGuardDamage(totalDamagePerResist, target.resistsArray, caster, target);\n            target.hp -= targetDamage;\n            if (attack > guardDefense) {\n                combatLog.guardFailsDefend(caster, target, target.buffs.guarded.caster);\n                guardDamage = calcGuardDamage(totalDamagePerResist, target.buffs.guarded.caster.resistsArray, caster, target.buffs.guarded.caster);\n                target.buffs.guarded.caster.hp -= guardDamage;\n            } else {\n                combatLog.guardDefend(caster, target, target.buffs.guarded.caster);\n            }\n        } else {\n            damageSum = calcTotalDamageAfterResists(totalDamagePerResist, target.resistsArray, caster, target); // * also calls combatLog()\n            target.hp -= sumOfArray(damageSum); \n        }\n        \n        return;\n    },\n\n    rangedAttack: function (caster, target) {\n        const mods = {\n            attackRollDice: 100,\n            attackBonus: caster.stats.dexterity,\n            defendRollDice: 20,\n            defendBonus\n\n        }\n        const attackRoll = dice(100);\n        const defendRoll = dice(20);\n        const attackBonus = caster.stats.dexterity;\n        const defendBonus = this.determineDefendBonus(caster, target);\n        const damage = this.determineDamage(caster);\n        const attack = attackRoll + attackBonus;\n        const defend = defendRoll + defendBonus;\n        if (attackRoll === 100) {\n            combatLog.critHit(caster, target, damage);\n            if (sumOfArray(damage) < 1) {\n                target.hp -= 2;\n            } else {\n                target.hp -= sumOfArray(damage) * 2;\n            }\n        } else {\n            combatLog.attackAttempt(caster, target, attackRoll, defendRoll, attackBonus, defendBonus);\n            if (attack >= defend) {\n                combatLog.hit(caster, target, damage);\n                if (sumOfArray(damage) < 1) {\n                    target.hp -= 1;\n                } else {\n                    target.hp -= sumOfArray(damage);\n                }\n            } else {\n                combatLog.defend(caster, target);\n            }\n        }\n    },\n\n    magicalAttack: function (caster, target) {\n        const mods = {\n            attackRollDice: 100,\n            attackBonus: caster.stats.dexterity,\n            defendRollDice: 20,\n            defendBonus\n\n        }\n        const attackRoll = dice(100);\n        const defendRoll = dice(20);\n        const attackBonus = caster.stats.dexterity;\n        const defendBonus = this.determineDefendBonus(caster, target);\n        const damage = this.determineDamage(caster);\n        const attack = attackRoll + attackBonus;\n        const defend = defendRoll + defendBonus;\n        if (attackRoll === 100) {\n            combatLog.critHit(caster, target, damage);\n            if (sumOfArray(damage) < 1) {\n                target.hp -= 2;\n            } else {\n                target.hp -= sumOfArray(damage) * 2;\n            }\n        } else {\n            combatLog.attackAttempt(caster, target, attackRoll, defendRoll, attackBonus, defendBonus);\n            if (attack >= defend) {\n                combatLog.hit(caster, target, damage);\n                if (sumOfArray(damage) < 1) {\n                    target.hp -= 1;\n                } else {\n                    target.hp -= sumOfArray(damage);\n                }\n            } else {\n                combatLog.defend(caster, target);\n            }\n        }\n    },\n\n    heal: function (caster, target) {\n        const healRoll = dice(100);\n        const healAmountRoll = dice(4);\n        const healBonus = caster.stats.willpower;\n        const healAmount = healAmountRoll + healBonus;\n        if (healRoll === 100) {\n            combatLog.critHeal(caster, target, healAmountRoll, healBonus, healAmount);\n            if (healAmount < 1) {\n                target.hp += 2;\n            } else {\n                target.hp += healAmount * 2;\n            }\n        } else {\n            combatLog.healAttempt(caster, target, healRoll, healBonus);\n            if (healRoll > 1) {\n                combatLog.heal(caster, target, healAmountRoll, healBonus, healAmount);\n                if (healAmount < 1) {\n                    target.hp += 1;\n                } else {\n                    target.hp += healAmount;\n                }\n            } else {\n                combatLog.healFail(caster, target);\n            }\n        }\n    },\n\n    guard: function (caster, target, mods) { // * For every attack made on the target, the caster takes half of that damage.\n        const targetBuff = {\n            name: mods.buffNameForTarget,\n            desc: mods.buffDescForTarget,\n            caster: caster,\n        }\n        const casterBuff = {\n            name: mods.buffNameForCaster,\n            desc: mods.buffDescForCaster,\n            target: target,\n        }\n        target.buffs.guarded = targetBuff;\n        if (caster.buffs.guarding) {\n            combatLog.guardSwitch(caster, target);\n            delete caster.buffs.guarding.target.buffs.guarded;\n            delete caster.buffs.guarding;\n            caster.buffs.guarding = casterBuff;\n        } else {\n            combatLog.guard(caster, target);\n            caster.buffs.guarding = casterBuff;\n        }\n    },\n    casterOnlyBuff: function (caster, mods) { // * Buff\n        const buff = mods;\n        caster.buffs[mods.buffNameForBuffObj] = buff;\n        combatLog.casterOnlyBuff(caster, buff);\n    },\n    debuff: function (caster, target, mods) { // * Buff\n        const targetDebuff = mods;\n        target.debuffs[mods.debuffNameForBuffObj] = targetDebuff;\n        combatLog.debuff(caster, target, targetDebuff);\n    },\n};\n/* #region  LOGIC */\nfunction calcGuardDamage(damage, resists, caster, target) { // * Takes two 9 index long resist arrays, outputs the aftermath of damage divided for the guard.\n    let damageSum = [0,0,0,0,0,0,0,0,0];\n    for(let i = 0; i < 9; i++) { // * cycles 9 times for each resist\n        if(damage[i] > 0) { // * If the damage is more than 0\n            if(resists[i] >=  damage[i]) {  // * If the resist is more than or equal to the damage, then 1 damage is taken.\n                damageSum[i] += 1;\n            } else if(resists[i] < 0){  // * If the resist is negative\n                if((resists[i] * -1) > damage[i]) { // * If the resist is more negative than the damage is positive, we just multiply the damage by 2, because a vulnerability cant do more than the original damage.\n                    damageSum[i] += damage[i] * 2;\n                } else { // * If the resist is negative, and all of it will be taken as damage, because the damage is higher than it.\n                    damageSum[i] += damage[i] + (resists[i] * -1);\n                }\n            } else { // * If the resist is positive, but is less than the total damage.\n                damageSum[i] += (damage[i] - resists[i])\n            }\n            damageSum[i] = Math.floor(damageSum[i] / 2);\n            combatLog.damageResist[i](damage[i], resists[i], damageSum[i], caster, target);\n        } else if (damageSum[i] < 0){ // * if the damage is negative, then 1 damage is taken, because you cannot deal negative damage on an attack.\n            damageSum[i] = Math.floor(damageSum[i] / 2);\n            combatLog.damageResist[i](damage[i], resists[i], damageSum[i], caster, target);\n            damageSum[i] += 1;\n        } else {\n            damageSum[i] = 0;\n        }\n    }\n    return damageSum;\n}\n\nfunction calcTargetWithGuardDamage(damage, resists, caster, target) { // * Takes two 9 index long resist arrays, outputs the aftermath of damage divided for target with guard.\n    let damageSum = [0,0,0,0,0,0,0,0,0];\n    for(let i = 0; i < 9; i++) { // * cycles 9 times for each resist\n        if(damage[i] > 0) { // * If the damage is more than 0\n            if(resists[i] >=  damage[i]) {  // * If the resist is more than or equal to the damage, then 1 damage is taken.\n                damageSum[i] += 1;\n            } else if(resists[i] < 0){  // * If the resist is negative\n                if((resists[i] * -1) > damage[i]) { // * If the resist is more negative than the damage is positive, we just multiply the damage by 2, because a vulnerability cant do more than the original damage.\n                    damageSum[i] += damage[i] * 2;\n                } else { // * If the resist is negative, and all of it will be taken as damage, because the damage is higher than it.\n                    damageSum[i] += damage[i] + (resists[i] * -1);\n                }\n            } else { // * If the resist is positive, but is less than the total damage.\n                damageSum[i] += (damage[i] - resists[i])\n            }\n            damageSum[i] = Math.ceil(damageSum[i] / 2);\n            combatLog.damageResist[i](damage[i], resists[i], damageSum[i], caster, target);\n        } else if (damageSum[i] < 0){ // * if the damage is negative, then 1 damage is taken, because you cannot deal negative damage on an attack.\n            damageSum[i] = Math.ceil(damageSum[i] / 2);\n            combatLog.damageResist[i](damage[i], resists[i], damageSum[i], caster, target);\n            damageSum[i] += 1;\n        } else {\n            damageSum[i] = 0;\n        }\n    }\n    return damageSum;\n}\n\nfunction calcTotalDamageAfterResists(damage, resists, caster, target) { // * Takes two 9 index long resist arrays, outputs the aftermath of damage.\n    let damageSum = [0,0,0,0,0,0,0,0,0];\n    for(let i = 0; i < 9; i++) { // * cycles 9 times for each resist\n        if(damage[i] > 0) { // * If the damage is more than 0\n            if(resists[i] >=  damage[i]) {  // * If the resist is more than or equal to the damage, then 1 damage is taken.\n                damageSum[i] += 1;\n            } else if(resists[i] < 0){  // * If the resist is negative\n                if((resists[i] * -1) > damage[i]) { // * If the resist is more negative than the damage is positive, we just multiply the damage by 2, because a vulnerability cant do more than the original damage.\n                    damageSum[i] += damage[i] * 2;\n                } else { // * If the resist is negative, and all of it will be taken as damage, because the damage is higher than it.\n                    damageSum[i] += damage[i] + (resists[i] * -1);\n                }\n            } else { // * If the resist is positive, but is less than the total damage.\n                damageSum[i] += (damage[i] - resists[i])\n            }\n            combatLog.damageResist[i](damage[i], resists[i], damageSum[i], caster, target);\n        } else if (damageSum[i] < 0){ // * if the damage is negative, then 1 damage is taken, because you cannot deal negative damage on an attack.\n            combatLog.damageResist[i](damage[i], resists[i], damageSum[i], caster, target);\n            damageSum[i] += 1;\n        } else {\n            damageSum[i] = 0;\n        }\n    }\n    return damageSum;\n}\n\nfunction calcTargetAttackAdvatages(caster) { // * Takes target as input, returns the total advantage count for their defend roll, counting buffs and debuffs.\n    let attackRollAdvantages = [];\n    Object.keys(caster.buffs).forEach((buffKey) => {\n        if (caster.buffs[buffKey].attackRollAdvantage) {\n            attackRollAdvantages.push(caster.buffs[buffKey].attackRollAdvantage);\n        }\n    });\n    Object.keys(caster.debuffs).forEach((buffKey) => {\n        if (caster.buffs[buffKey].attackRollAdvantage) {\n            attackRollAdvantages.push(caster.buffs[buffKey].attackRollAdvantage);\n        }\n    });\n    return sumOfArray(attackRollAdvantages);\n}\n\nfunction calcTargetDefendAdvatages(target) { // * Takes target as input, returns the total advantage count for their defend roll, counting buffs and debuffs.\n    let defendRollAdvantages = [];\n    Object.keys(target.buffs).forEach((buffKey) => {\n        if (target.buffs[buffKey].defendRollAdvantage) {\n            defendRollAdvantages.push(target.buffs[buffKey].defendRollAdvantage);\n        }\n    });\n    Object.keys(target.debuffs).forEach((buffKey) => {\n        if (target.buffs[buffKey].defendRollAdvantage) {\n            defendRollAdvantages.push(target.buffs[buffKey].defendRollAdvantage);\n        }\n    });\n    return sumOfArray(defendRollAdvantages);\n}\n\nfunction rollWithAdvantageCount(diceSize, advantageCount) { // * Takes a dice size input, and a advantage or disadvantage count input (pos 1 will be a regular roll, lower will be disadvantage and higher will be advantage) returns the highest or lowest number respectiveley.\n    let arrOfRolls = [];\n    let isAdvantageCountPos;\n    if (advantageCount < 0) {\n        advantageCount *= -1;\n        isAdvantageCountPos = false;\n    } else {\n        isAdvantageCountPos = true;\n    }\n    advantageCount += 1;\n    for (let i = 0; i < advantageCount; i++) {\n        arrOfRolls.push(dice(diceSize))\n    };\n    if (isAdvantageCountPos) {\n        return Math.max(...arrOfRolls);\n    } else {\n        return Math.min(...arrOfRolls);\n    }\n}\n\nfunction getGuardDefense(attackType, guarder) {\n    const guarderBlock = Math.floor((guarder.stats.initiative / 2) + guarder.block);\n    let returnValue;\n    switch (attackType) {\n        case `melee`:\n            const guarderParry = Math.floor((guarder.stats.initiative / 2) + (guarder.stats.dexterity / 4) + guarder.parry);\n            returnValue = Math.max(guarderParry, guarderBlock);\n            break;\n        case `ranged`:\n            const guarderDodge = Math.floor((guarder.stats.initiative / 2) + (guarder.stats.agility / 4) + guarder.dodge);\n            returnValue = Math.max(guarderDodge, guarderBlock);\n            break;\n        case `magic`:\n            const guarderDisrupt = Math.floor((guarder.stats.initiative / 2) + (guarder.stats.willpower / 4) + guarder.disrupt);\n            returnValue = Math.max(guarderDisrupt, guarderBlock);\n            break;\n    }\n    return returnValue;\n}\n\nfunction doesArrayOfObjectsIncludeIndexOf(array, propertyName, value) {\n    array.forEach((ele) => {\n        if (ele[propertyName] === value) {\n            let index = array.indexOf(ele);\n            return index;\n        }\n        return false;\n    });\n}\n\nfunction doesArrayOfObjectsInclude(array, propertyName, value) {\n    array.forEach((ele) => {\n        if (ele[propertyName] === value) {\n            return true;\n        }\n        return false;\n    });\n}\n\nfunction concatRollDice(...args) { // * Takes multiple 2D dice array input like rollDice does, but outputs will ignore null inputs.\n    let outputArr = [];\n    args.forEach((el) => {\n        if (el) {\n            let i = rollDice(el);\n            outputArr = outputArr.concat(i);\n        }\n    });\n    return outputArr;\n}\n\nfunction rollDice(diceArr) { // * Takes a 2D dice array input like so: [ [2,4] , [3,6] ] - equivilent to 2d4 + 3d6. Outputs array of each individual roll result, now with resistances.\n    if (diceArr === null) {\n        return null;\n    }\n    let rollArr = [];\n    for (let i = 0; i < diceArr.length; i++) {\n        for (let x = 0; x < diceArr[i][1]; x++) {\n\n            rollArr.push([diceArr[i][0],dice(diceArr[i][2])]);\n        }\n    }\n    return rollArr;\n}\n\nfunction dice(dMax) { // * Takes an integer number X as input and outputs a random number between 1 and X like a single dice roll.\n    return Math.floor(Math.random() * dMax + 1);\n}\n\nfunction diceMinus1(dMax) { // * Takes an integer number X as input and outputs a random number between 0 and X.\n    return Math.floor(Math.random() * dMax + 1) - 1;\n}\n\nfunction sumOfDamageArray(arrayOfNumbers) { // * Takes a 2D array of numbers and adds the index [1's] up, then returns an array 9 indexes long representing each damage resist type, and how much of that type was sumed.\n    if (arrayOfNumbers === null) {\n        return null;\n    }\n    let sum = [0,0,0,0,0,0,0,0,0];\n    for (let i = 0; i < arrayOfNumbers.length; i++) {\n        sum[arrayOfNumbers[i][0]] += arrayOfNumbers[i][1];\n    }\n    return sum;\n}\n\nfunction sumOfArray(arrayOfNumbers) { // * Takes a 1D array of numbers and adds them up, then returns the sum.\n    let sum = 0;\n    arrayOfNumbers.forEach((el) => { if (el === null) { el = 0 } sum += el });\n    return sum;\n}\n\nfunction popArrayPopValue(array) {\n    let arrayCopy = Object.assign([], array);\n    return arrayCopy.pop();\n}\n\nfunction popArrayArrayValue(array) {\n    let arrayCopy = Object.assign([], array);\n    arrayCopy.pop();\n    return arrayCopy;\n}\n\nfunction isTargetDead(target) {\n    if (target.hp < 1) {\n        console.log(`Target is dead.`)\n        return true\n    }\n}\n\nfunction isAttackingAllies(caster, target) {\n    if (caster.groupName === `PC` && target.groupName === `PC`) {\n        console.log(`Don't attack your allies!`);\n        return true\n    }\n    if (caster.groupName === `NPC` && target.groupName === `NPC`) {\n        return true\n    }\n    return false;\n};\n\nfunction isHealingEnemies(caster, target) {\n    if (caster.groupName === `PC` && target.groupName === `NPC`) {\n        console.log(`Don't heal the enemy!`);\n        return true\n    }\n    if (caster.groupName === `NPC` && target.groupName === `PC`) {\n        return true\n    }\n    return false;\n};\n\nfunction isBuffingEnemies(caster, target) {\n    if (caster.groupName === `PC` && target.groupName === `NPC`) {\n        console.log(`Don't buff the enemy!`);\n        return true\n    }\n    if (caster.groupName === `NPC` && target.groupName === `PC`) {\n        return true\n    }\n    return false;\n};\n\nfunction isHealingDeadTarget(target, abilityName) {\n    if (target.hp < 1) {\n        console.log(`${abilityName} is not powerful enough to ressurect ${target.name}.`)\n        return true\n    }\n};\n\nfunction forceHPtoZero(char) {\n    if (char.hp < 0) {\n        char.hp = 0;\n    }\n};\n\nfunction isTargetInRangeOfCaster(caster, target, abilityRange) {\n    let casterRowConverted;\n    let targetRowConverted;\n    if (caster.groupName !== target.groupName) {\n        if(caster.groupName === `PC`) {\n            switch (caster.row) {\n                case 3:\n                    casterRowConverted = 6;\n                break;\n                case 2:\n                    casterRowConverted = 5;\n                break;\n                case 1:\n                    casterRowConverted = 4;\n                break;\n            }\n            switch (target.row) {\n                case 3:\n                    targetRowConverted = 1;\n                break;\n                case 2:\n                    targetRowConverted = 2;\n                break;\n                case 1:\n                    targetRowConverted = 3;\n                break;\n            }\n            if(Math.abs(casterRowConverted - targetRowConverted) <= abilityRange) {\n                return true;\n            } else {\n                return false;\n            }\n        }\n        if(caster.groupName === `NPC`) {\n            switch (caster.row) {\n                case 3:\n                    casterRowConverted = 1;\n                break;\n                case 2:\n                    casterRowConverted = 2;\n                break;\n                case 1:\n                    casterRowConverted = 3;\n                break;\n            }\n            switch (target.row) {\n                case 3:\n                    targetRowConverted = 6;\n                break;\n                case 2:\n                    targetRowConverted = 5;\n                break;\n                case 1:\n                    targetRowConverted = 4;\n                break;\n            }\n            if(Math.abs(casterRowConverted - targetRowConverted) <= abilityRange) {\n                return true;\n            } else {\n                return false;\n            }\n        }\n    } else {\n        if(caster.groupName === `PC`) {\n            switch (caster.row) {\n                case 3:\n                    casterRowConverted = 6;\n                break;\n                case 2:\n                    casterRowConverted = 5;\n                break;\n                case 1:\n                    casterRowConverted = 4;\n                break;\n            }\n            switch (target.row) {\n                case 3:\n                    targetRowConverted = 6;\n                break;\n                case 2:\n                    targetRowConverted = 5;\n                break;\n                case 1:\n                    targetRowConverted = 4;\n                break;\n            }\n            if((Math.abs(casterRowConverted - targetRowConverted) <= abilityRange)) {\n                return true;\n            } else {\n                return false;\n            }\n        }\n        if(caster.groupName === `NPC`) {\n            switch (caster.row) {\n                case 3:\n                    casterRowConverted = 1;\n                break;\n                case 2:\n                    casterRowConverted = 2;\n                break;\n                case 1:\n                    casterRowConverted = 3;\n                break;\n            }\n            switch (target.row) {\n                case 3:\n                    targetRowConverted = 1;\n                break;\n                case 2:\n                    targetRowConverted = 2;\n                break;\n                case 1:\n                    targetRowConverted = 3;\n                break;\n            }\n            if((Math.abs(casterRowConverted - targetRowConverted) <= abilityRange)) {\n                return true;\n            } else {\n                return false;\n            }\n        }\n    }\n    \n};\n\n/* #endregion END LOGIC*/\n\n/* #endregion Ability Effects & Logic*/\n\n/* #region All Lists */\n\nconst allAbilities = [];\nfunction defineAllAbilities() {\n    allAbilities[0] = {\n        name: `Attack`,\n        effect: function (caster, target) {\n            if (!isAttackingAllies(caster, target)) {\n                if (!isTargetDead(target)) {\n                    if (turn.AP >= this.APCost) {\n                        const mods = {\n                            abilityIndex: 0,\n                            abilityRange: caster.equipment.mainHand.range,\n                            attackRollDice: 100,\n                            attackBonus: caster.stats.dexterity,\n                            damageRollDice: {\n                                mainHandWeapon: caster.equipment.mainHand.damage,\n                                offHandWeapon: caster.equipment.offHand.damage,\n                                ability: null,\n                            },\n                            damageBonus: [0, caster.stats.strength],\n                            critThreshold: 100,\n                            critMultiplier: 2,\n                            defendRollDice: 20,\n                            targetParry: Math.floor((target.stats.initiative / 2) + (target.stats.dexterity / 4) + target.parry),\n                            targetDodge: Math.floor((target.stats.initiative / 2) + (target.stats.agility / 4) + target.dodge),\n                            targetDisrupt: Math.floor((target.stats.initiative / 2) + (target.stats.willpower / 4) + target.disrupt),\n                            targetBlock: Math.floor((target.stats.initiative / 2) + target.block),\n                            getDefendBonus: function () {\n                                return Math.max(this.targetParry, this.targetBlock)\n                            },\n                        };\n                        if(isTargetInRangeOfCaster(caster, target, mods.abilityRange)) {\n                            effect.meleeAttack(caster, target, mods); turn.AP -= this.APCost\n                        } else {\n                            combatLog.targetNotInRange(target, this.name);\n                        }\n                    } else {\n                        combatLog.noAP(this.name, this.APCost);\n                    }\n                }\n            }\n        },\n        APCost: 20,\n    }\n    allAbilities[1] = {\n        name: `Powerful Strike`,\n        effect: function (caster, target) {\n            if (!isAttackingAllies(caster, target)) {\n                if (!isTargetDead(target)) {\n                    if (turn.AP >= this.APCost) {\n                        const mods = {\n                            abilityIndex: 1,\n                            abilityRange: 1,\n                            attackRollDice: 100,\n                            attackBonus: caster.stats.strength,\n                            damageRollDice: {\n                                mainHandWeapon: caster.equipment.mainHand.damage,\n                                offHandWeapon: caster.equipment.offHand.damage,\n                                ability: null,\n                            },\n                            damageBonus: Math.floor(caster.stats.strength * 1.5),\n                            critThreshold: 100,\n                            critMultiplier: 2,\n                            defendRollDice: 20,\n                            targetParry: Math.floor((target.stats.initiative / 2) + (target.stats.dexterity / 4) + target.parry),\n                            targetDodge: Math.floor((target.stats.initiative / 2) + (target.stats.agility / 4) + target.dodge),\n                            targetDisrupt: Math.floor((target.stats.initiative / 2) + (target.stats.willpower / 4) + target.disrupt),\n                            targetBlock: Math.floor((target.stats.initiative / 2) + target.block),\n                            getDefendBonus: function () {\n                                return Math.max(this.targetParry, this.targetBlock)\n                            },\n                        };\n                        if(isTargetInRangeOfCaster(caster, target, mods.abilityRange)) {\n                            effect.meleeAttack(caster, target, mods); turn.AP -= this.APCost\n                        } else {\n                            combatLog.targetNotInRange(target, this.name);\n                        }\n                    } else {\n                        combatLog.noAP(this.name, this.APCost);\n                    }\n                }\n            }\n        },\n        APCost: 25,\n    }\n    allAbilities[2] = {\n        name: `Precision Strike`,\n        effect: function (caster, target) {\n            if (!isAttackingAllies(caster, target)) {\n                if (!isTargetDead(target)) {\n                    if (turn.AP >= this.APCost) {\n                        const mods = {\n                            abilityIndex: 1,\n                            abilityRange: caster.equipment.mainHand.range,\n                            attackRollDice: 100,\n                            attackBonus: caster.stats.dexterity * 2,\n                            damageRollDice: {\n                                mainHandWeapon: caster.equipment.mainHand.damage,\n                                offHandWeapon: caster.equipment.offHand.damage,\n                                ability: null,\n                            },\n                            damageBonus: Math.floor(caster.stats.dexterity * 1.5),\n                            critThreshold: 100,\n                            critMultiplier: 2,\n                            defendRollDice: 20,\n                            targetParry: Math.floor((target.stats.initiative / 2) + (target.stats.dexterity / 4) + target.parry),\n                            targetDodge: Math.floor((target.stats.initiative / 2) + (target.stats.agility / 4) + target.dodge),\n                            targetDisrupt: Math.floor((target.stats.initiative / 2) + (target.stats.willpower / 4) + target.disrupt),\n                            targetBlock: Math.floor((target.stats.initiative / 2) + target.block),\n                            getDefendBonus: function () {\n                                return Math.max(this.targetParry, this.targetBlock)\n                            },\n                        };\n                        if(isTargetInRangeOfCaster(caster, target, mods.abilityRange)) {\n                            effect.meleeAttack(caster, target, mods); turn.AP -= this.APCost\n                        } else {\n                            combatLog.targetNotInRange(target, this.name);\n                        }\n                    } else {\n                        combatLog.noAP(this.name, this.APCost);\n                    }\n                }\n            }\n        },\n        APCost: 25,\n    }\n    allAbilities[3] = {\n        name: `Healing Word`,\n        effect: function (caster, target) {\n            if (!isHealingEnemies(caster, target)) {\n                if (!isHealingDeadTarget(target, this.name)) {\n                    if (turn.AP >= this.APCost) {\n                        const mods = {\n                            abilityIndex: 1,\n                            abilityRange: 1,\n                            attackRollDice: 100,\n                            attackBonus: caster.stats.dexterity * 2,\n                            damageRollDice: {\n                                mainHandWeapon: caster.equipment.mainHand.damage,\n                                offHandWeapon: caster.equipment.offHand.damage,\n                                ability: null,\n                            },\n                            damageBonus: Math.floor(caster.stats.dexterity * 1.5),\n                            critThreshold: 100,\n                            critMultiplier: 2,\n                            defendRollDice: 20,\n                            targetParry: Math.floor((target.stats.initiative / 2) + (target.stats.dexterity / 4) + target.parry),\n                            targetDodge: Math.floor((target.stats.initiative / 2) + (target.stats.agility / 4) + target.dodge),\n                            targetDisrupt: Math.floor((target.stats.initiative / 2) + (target.stats.willpower / 4) + target.disrupt),\n                            targetBlock: Math.floor((target.stats.initiative / 2) + target.block),\n                            getDefendBonus: function () {\n                                return Math.max(this.targetParry, this.targetBlock)\n                            },\n                        };\n                        if(isTargetInRangeOfCaster(caster, target, mods.abilityRange)) {\n                            effect.heal(caster, target); turn.AP -= this.APCost\n                        } else {\n                            combatLog.targetNotInRange(target, this.name);\n                        }\n                    } else {\n                        combatLog.noAP(this.name, this.APCost);\n                    }\n                }\n            }\n        },\n        APCost: 10,\n    }\n    allAbilities[4] = {\n        name: `Guard`,\n        effect: function (caster, target) {\n            if (!isBuffingEnemies(caster, target)) {\n                if (!isTargetDead(target)) {\n                    if (!target.buffs.guarded) {\n                        if (turn.AP >= this.APCost) {\n                            const mods = {\n                                abilityIndex: 1,\n                                abilityRange: 1,\n                                buffNameForTarget: `Guarded`,\n                                buffNameForCaster: `Guarding`,\n                                buffDescForTarget: `Guarded by ${caster.name}`,\n                                buffDescForCaster: `Guarding ${target.name}`,\n                            };\n                            if(isTargetInRangeOfCaster(caster, target, mods.abilityRange)) {\n                                effect.guard(caster, target, mods); turn.AP -= this.APCost\n                            } else {\n                                combatLog.targetNotInRange(target, this.name);\n                            }\n                        } else {\n                            combatLog.noAP(this.name, this.APCost);\n                        }\n                    }\n                }\n            }\n        },\n        APCost: 50,\n    }\n    allAbilities[5] = {\n        name: `Leaping Strike`,\n        effect: function (caster, target) {\n            if (!isAttackingAllies(caster, target)) {\n                if (!isTargetDead(target)) {\n                    if (turn.AP >= this.APCost) {\n                        const mods = {\n                            abilityIndex: 0,\n                            abilityRange: 2,\n                            attackRollDice: 100,\n                            attackBonus: caster.stats.dexterity,\n                            damageRollDice: {\n                                mainHandWeapon: caster.equipment.mainHand.damage,\n                                offHandWeapon: caster.equipment.offHand.damage,\n                                ability: null,\n                            },\n                            damageBonus: caster.stats.strength,\n                            critThreshold: 100,\n                            critMultiplier: 2,\n                            defendRollDice: 20,\n                            targetParry: Math.floor((target.stats.initiative / 2) + (target.stats.dexterity / 4) + target.parry),\n                            targetDodge: Math.floor((target.stats.initiative / 2) + (target.stats.agility / 4) + target.dodge),\n                            targetDisrupt: Math.floor((target.stats.initiative / 2) + (target.stats.willpower / 4) + target.disrupt),\n                            targetBlock: Math.floor((target.stats.initiative / 2) + target.block),\n                            getDefendBonus: function () {\n                                return Math.max(this.targetParry, this.targetBlock)\n                            },\n                        };\n                        if(isTargetInRangeOfCaster(caster, target, mods.abilityRange)) {\n                            effect.meleeAttack(caster, target, mods); turn.AP -= this.APCost\n                        } else {\n                            combatLog.targetNotInRange(target, this.name);\n                        }\n                    } else {\n                        combatLog.noAP(this.name, this.APCost);\n                    }\n                }\n            }\n        },\n        APCost: 20,\n    }\n    allAbilities[6] = {\n        name: `Reflexive Focus`, // TODO: Make this ability drain 5 ap every turn that it is active, also need a way to see that it is active and a way to disable it.\n        effect: function (caster, target) {\n            if (!caster.buffs.reflexiveFocus) {\n                if (turn.AP >= this.APCost) {\n                    const mods = {\n                        name: `Reflexive Focus`,\n                        desc: `${caster.name} is focused on his defenses, giving advantage on defense rolls. `,\n                        buffNameForBuffObj: `reflexiveFocus`,\n                        defendRollAdvantage: 1,\n                    };\n                    effect.casterOnlyBuff(caster, mods); turn.AP -= this.APCost\n                } else {\n                    combatLog.noAP(this.name, this.APCost);\n                }\n            } else {\n                // TODO: Need a combat log for the target\n            }\n        },\n        APCost: 5,\n    }\n    allAbilities[7] = {\n        name: `Reveal Weakness`,\n        effect: function (caster, target) {\n            if (!isAttackingAllies(caster, target)) {\n                if (!isTargetDead(target)) {\n                    if (turn.AP >= this.APCost) {\n                        const mods = {\n                            name: `Reveal Weakness`,\n                            desc: `${caster.name} has revealed ${target.name}'s weakness, giving him disadvantage on defense, and he takes 1 extra damage from all attacks. `,\n                            debuffNameForBuffObj: `revealWeakness`,\n                            defendRollAdvantage: -1,\n                            abilityRange: 5,\n                        };\n                        if(isTargetInRangeOfCaster(caster, target, mods.abilityRange)) {\n                            effect.debuff(caster, target, mods); turn.AP -= this.APCost\n                        } else {\n                            combatLog.targetNotInRange(target, this.name);\n                        }\n                    } else {\n                        combatLog.noAP(this.name, this.APCost);\n                    }\n                }\n            }\n        },\n        APCost: 75,\n    }\n    allAbilities[8] = {\n        name: `Flesh Eating`,\n        effect: function (caster, target) {\n            if (!isAttackingAllies(caster, target)) {\n                if (turn.AP >= this.APCost) {\n                    effect.attack(caster, target); turn.AP -= this.APCost\n                } else {\n                    combatLog.noAP(this.name, this.APCost);\n                }\n            }\n        },\n        APCost: 25,\n    }\n    allAbilities[9] = {\n        name: `Riposte`,\n        effect: function (caster, target) {\n            if (!isAttackingAllies(caster, target)) {\n                if (!isTargetDead(target)) {\n                    const mods = {\n                        isRiposte: true,\n                        abilityIndex: 9,\n                        attackRollDice: 100,\n                        attackBonus: caster.stats.dexterity,\n                        damageRollDice: {\n                            mainHandWeapon: caster.equipment.mainHand.damage,\n                            offHandWeapon: caster.equipment.offHand.damage,\n                            ability: null,\n                        },\n                        damageBonus: caster.stats.strength,\n                        critThreshold: 100,\n                        critMultiplier: 2,\n                        defendRollDice: 20,\n                        targetParry: Math.floor((target.stats.initiative / 2) + (target.stats.dexterity / 4) + target.parry),\n                        targetDodge: Math.floor((target.stats.initiative / 2) + (target.stats.agility / 4) + target.dodge),\n                        targetDisrupt: Math.floor((target.stats.initiative / 2) + (target.stats.willpower / 4) + target.disrupt),\n                        targetBlock: Math.floor((target.stats.initiative / 2) + target.block),\n                        getDefendBonus: function () {\n                            return Math.max(this.targetParry, this.targetBlock)\n                        },\n                    };\n                    effect.meleeAttack(caster, target, mods); turn.AP -= this.APCost\n                }\n            }\n        },\n        APCost: 0,\n    }\n}\n\nconst allWeapons = [];\nfunction defineAllWeapons() {\n    allWeapons[0] = {\n        name: `Unarmed`,\n        type: `melee`,\n        damage: [[0, 1, 4]],\n        range: 1,\n        parry: 0,\n        dodge: 0,\n        disrupt: 0,\n        block: 0,\n    }\n    allWeapons[1] = {\n        name: `Dagger`,\n        type: `melee`,\n        damage: [[0, 2, 4]],\n        range: 1,\n        parry: 1,\n        dodge: 0,\n        disrupt: 0,\n        block: 0,\n    }\n}\n\nconst allArmors = [];\nfunction defineAllArmors() {\n    allArmors[0] = {\n        name: `None`,\n        parry: 0,\n        dodge: 0,\n        disrupt: 0,\n        block: 0,\n    }\n    allArmors[1] = {\n        name: `Chainmail`,\n        parry: 1,\n        dodge: 0,\n        disrupt: 0,\n        block: 0,\n    }\n}\n\nconst allRaces = [];\nfunction defineAllRaces() {\n    allRaces[0] = {\n        name: `Man`,\n        stats: {\n            strength: 0,\n            dexterity: 0,\n            willpower: 0,\n            vitality: 0,\n            agility: 0,\n            initiative: 0,\n            intelligence: 4,\n            charisma: 0,\n        },\n        resists: {\n            flat: 0,\n            piercing: 0,\n            ice: -5,\n            fire: -5,\n            corrosive: -5,\n            poison: -5,\n            spiritual: -5,\n            lighting: -5,\n            arcane: -5,\n        },\n        resistsArray: [0,0,-5,-5,-5,-5,-5,-5,-5],   \n    };\n    allRaces[1] = {\n        name: `Elf`,\n        stats: {\n            strength: -2,\n            dexterity: 2,\n            willpower: 0,\n            vitality: -4,\n            agility: 0,\n            initiative: 0,\n            intelligence: 8,\n            charisma: 0,\n        },\n        resists: {\n            flat: 0,\n            piercing: 0,\n            ice: -5,\n            fire: -5,\n            corrosive: -5,\n            poison: -5,\n            spiritual: -5,\n            lighting: -5,\n            arcane: -5,\n        },\n        resistsArray: [0,0,-5,-5,-5,-5,-5,-5,-5],   \n    };\n    allRaces[2] = {\n        name: `Dwarf`,\n        stats: {\n            strength: 2,\n            dexterity: 0,\n            willpower: 2,\n            vitality: 4,\n            agility: -8,\n            initiative: 0,\n            intelligence: 4,\n            charisma: 0,\n        },\n        resists: {\n            flat: 0,\n            piercing: 0,\n            ice: -3,\n            fire: -3,\n            corrosive: -3,\n            poison: -3,\n            spiritual: -3,\n            lighting: -3,\n            arcane: -3,\n        },\n        resistsArray: [0,0,-3,-3,-3,-3,-3,-3,-3],   \n\n    };\n    allRaces[3] = {\n        name: `Saurus`,\n        stats: {\n            strength: 14,\n            dexterity: -2,\n            willpower: 4,\n            vitality: 14,\n            agility: 2,\n            initiative: 4,\n            intelligence: -14,\n            charisma: -18,\n        },\n        resists: {\n            flat: 5,\n            piercing: 5,\n            ice: 0,\n            fire: 0,\n            corrosive: 0,\n            poison: 0,\n            spiritual: -5,\n            lighting: 0,\n            arcane: -5,\n        },\n        resistsArray: [5,5,0,0,0,0,-5,0,-5],   \n    };\n}\n\nconst allTalents = [];\nfunction defineAllTalents() {\n    allTalents[0] = {\n        name: `Strong`,\n        statBonusName: `strength`,\n        statBonusAmount: 4,\n        ability: 1,\n    };\n    allTalents[1] = {\n        name: `Dexterous`,\n        statBonusName: `dexterity`,\n        statBonusAmount: 4,\n        ability: 2,\n    };\n    allTalents[2] = {\n        name: `Soulful`,\n        statBonusName: `willpower`,\n        statBonusAmount: 4,\n        ability: 3,\n    };\n    allTalents[3] = {\n        name: `Resilient`,\n        statBonusName: `vitality`,\n        statBonusAmount: 4,\n        ability: 4,\n    };\n    allTalents[4] = {\n        name: `Agile`,\n        statBonusName: `agility`,\n        statBonusAmount: 4,\n        ability: 5,\n    };\n    allTalents[5] = {\n        name: `Responsive`,\n        statBonusName: `initiative`,\n        statBonusAmount: 4,\n        ability: 6,\n    };\n    allTalents[6] = {\n        name: `Genius`,\n        statBonusName: `intelligence`,\n        statBonusAmount: 4,\n        ability: 7,\n    };\n    allTalents[7] = {\n        name: `Charismatic`,\n        statBonusName: `charisma`,\n        statBonusAmount: 4,\n        ability: 8,\n    };\n    allTalents[8] = {\n        name: `Sorcerous`,\n    };\n}\n\nconst allFeats = [];\nfunction defineAllFeats() {\n    allFeats[0] = {\n        name: `Brute Force`,\n        parry: 0,\n        dodge: 0,\n        disrupt: 0,\n        block: 0,\n    }\n    allFeats[1] = {\n        name: `Heavy Strikes`,\n        parry: 1,\n        dodge: 0,\n        disrupt: 0,\n        block: 0,\n    }\n}\n\nconst allBackgrounds = [];\nfunction defineAllBackgrounds() {\n    allBackgrounds[0] = {\n        name: `Peasant`,\n        parry: 0,\n        dodge: 0,\n        disrupt: 0,\n        block: 0,\n    }\n    allBackgrounds[1] = {\n        name: `Mercenary`,\n        parry: 1,\n        dodge: 0,\n        disrupt: 0,\n        block: 0,\n    }\n}\n\n/* #endregion All Lists*/\n\n/* #region  Groups */\n\n// Index 0 is always the main/player character\n\nconst PCs = {\n    name: `PC`,\n    charList: [],\n}\n\nconst NPCs = {\n    name: `NPC`,\n    charList: [],\n}\n\nconst unassignedGroup = {\n    name: `Unassigned`,\n    charList: [],\n}\n\n/* #endregion Groups */\n\n/* #region  Char Creation */\n\nfunction Char(name, race) {\n    this.name = `${name}`;\n    this.groupName = ``;\n    this.raceName = `${race.name}`;\n    this.talent1Name = ``;\n    this.talent2Name = ``;\n    this.hp = 100;\n    this.abilities = [0];\n    this.stats = race.stats;\n    this.resists = race.resists;\n    this.resistsArray = race.resistsArray; \n    this.buffs = {};\n    this.debuffs = {};\n    this.row = 1;\n    this.equipment = {\n        mainHand: allWeapons[0],\n        offHand: allWeapons[0],\n        armor: allArmors[0],\n    };\n    this.addEquipment = function (slotName, equipment) {\n        this.equipment[slotName] = equipment;\n        this.parry = sumOfArray([this.equipment.mainHand.parry, this.equipment.offHand.parry, this.equipment.armor.parry]);\n        this.dodge = sumOfArray([this.equipment.mainHand.dodge, this.equipment.offHand.dodge, this.equipment.armor.dodge]);\n        this.disrupt = sumOfArray([this.equipment.mainHand.disrupt, this.equipment.offHand.disrupt, this.equipment.armor.disrupt]);\n        this.block = sumOfArray([this.equipment.mainHand.block, this.equipment.offHand.block, this.equipment.armor.block]);\n    };\n    this.addStatBonus = function (statName, amount) {\n        switch (statName) {\n            case `strength`:\n                this.stats.strength += amount;\n                break;\n            case `dexterity`:\n                this.stats.dexterity += amount;\n                break;\n            case `willpower`:\n                this.stats.willpower += amount;\n                break;\n            case `vitality`:\n                this.stats.vitality += amount;\n                break;\n            case `agility`:\n                this.stats.agility += amount;\n                break;\n            case `initiative`:\n                this.stats.initiative += amount;\n                break;\n            case `intelligence`:\n                this.stats.intelligence += amount;\n                break;\n            case `charisma`:\n                this.stats.charisma += amount;\n                break;\n        }\n    };\n    this.useAbility = function (abilityIndex, target) {\n        if (this.hp > 0) {\n            if (this.abilities.includes(+abilityIndex) || +abilityIndex === 9) {\n                allAbilities[abilityIndex].effect(this, target);\n            } else {\n                console.log(`Err: Char does not have this ability`);\n            }\n        } else {\n            combatLog.charIsDead(this, allAbilities[abilityIndex]);\n        }\n    };\n    this.getTalentNames = function () {\n        return this.talent1Name + this.talent2Name;\n    };\n    this.initCharReferenceForChildObjects = function (childObject) {\n        this[childObject].char = this;\n        delete this.initCharReferenceForChildObjects;\n        return this;\n    };\n    /*     \n        this.inventory = {\n            hands: [null,null,null,null],\n            backpack: false,\n            saddlebag: false,\n            properties: false,\n        };\n    */\n\n};\n\nfunction characterCreator(name, race, talent1, talent2, group) {\n    function createChar(name, race) {\n        unassignedGroup.charList.push(new Char(name, race));\n    }\n    function addTalents(talent1, talent2) {\n        // targetChar is always equal to the latest created character in the unnassignedGroup.charList array.\n        const targetChar = unassignedGroup.charList[unassignedGroup.charList.length - 1];\n        const talent1StatBonusName = talent1.statBonusName;\n        const talent1StatBonusAmount = talent1.statBonusAmount;\n        const talent2StatBonusName = talent2.statBonusName;\n        const talent2StatBonusAmount = talent2.statBonusAmount;\n        const talent1Ability = talent1.ability;\n        const talent2Ability = talent2.ability;\n        targetChar.talent1Name = talent1.name;\n        targetChar.talent2Name = talent2.name;\n        targetChar.addStatBonus(talent1StatBonusName, talent1StatBonusAmount);\n        targetChar.addStatBonus(talent2StatBonusName, talent2StatBonusAmount);\n        targetChar.abilities.push(talent1Ability);\n        targetChar.abilities.push(talent2Ability);\n    }\n    function addEquipment() {\n        const targetChar = unassignedGroup.charList[unassignedGroup.charList.length - 1];\n        targetChar.addEquipment(`armor`, allArmors[0]);\n    }\n    function assignGroup(group) {\n        const targetChar = unassignedGroup.charList[unassignedGroup.charList.length - 1];\n        targetChar.groupName = group.name;\n        group.charList.push(targetChar);\n        unassignedGroup.charList.pop();\n    }\n    createChar(name, race);\n    addTalents(talent1, talent2);\n    addEquipment();\n    assignGroup(group);\n};\n\n/* #endregion Char Creation*/\n\n/* #region  DOM */\n\nconst DOM = {\n    moveRowButtons: document.querySelector(`.moveRowButtons`),\n    equipmentList: document.querySelector(`.equipmentList`),\n    endTurnButton: document.querySelector(`.endTurnButton`),\n    APCount: document.querySelector(`.APCount`),\n    casterSelectionDisplay: document.querySelector(`.casterSelectionDisplay`),\n    targetSelectionDisplay: document.querySelector(`.targetSelectionDisplay`),\n    PCBar: document.querySelector(`.PCBar`),\n    PCBarRow1: document.querySelector(`.PCBarRow1`),\n    PCBarRow2: document.querySelector(`.PCBarRow2`),\n    PCBarRow3: document.querySelector(`.PCBarRow3`),\n    NPCBarRow1: document.querySelector(`.NPCBarRow1`),\n    NPCBarRow2: document.querySelector(`.NPCBarRow2`),\n    NPCBarRow3: document.querySelector(`.NPCBarRow3`),\n    NPCBar: document.querySelector(`.NPCBar`),\n    abilityListContainer: document.querySelector(`.abilityListContainer`),\n    botBar: document.querySelector(`.botBar`),\n    midBar: document.querySelector(`.midBar`),\n    casterSelection: null,\n    targetSelection: null,\n    casterSelectionState: null,\n    targetSelectionState: null,\n\n    listenForEndTurnButton: function () {\n        this.endTurnButton.addEventListener(`click`, (e) => {\n            turn.end();\n        })\n    },\n\n    listenForMoveRowButtons: function () {\n        this.moveRowButtons.addEventListener(`click`, (e) => {\n            if(e.target.className === `up` && this.casterSelectionState !== null) {\n                if(this.casterSelectionState.row > 1) {\n                    this.casterSelectionState.row -= 1;\n                }\n            }\n            if(e.target.className === `down` && this.casterSelectionState !== null) {\n                if(this.casterSelectionState.row < 3) {\n                    this.casterSelectionState.row += 1;\n                }\n            }\n            this.update();\n        })\n    },\n\n    attemptAbilityCast: function (target) {\n        const abilityNameSubDiv = target.querySelector(`.abilityName`);\n        const abilityDatasetIndex = abilityNameSubDiv.dataset.abilityIndex;\n        if ((this.casterSelectionState && this.targetSelectionState) !== null) {\n            this.casterSelectionState.useAbility(abilityDatasetIndex, this.targetSelectionState)\n        } else {\n            console.log(`invalid targets`);\n        }\n        this.update();\n        this.updateTopBar();\n    },\n\n    listenForBotBar: function () {\n        this.botBar.addEventListener(`click`, (e) => {\n            switch (e.target.className) {\n                case `ability`:\n                    this.attemptAbilityCast(e.target);\n                    break;\n                case `slideLeft`:\n\n                    break;\n                case `slideRight`:\n\n                    break;\n            }\n        })\n    },\n\n    updateTopBar: function () {\n        if (this.casterSelectionState) {\n            this.casterSelectionDisplay.textContent = `Caster: ${this.casterSelectionState.name}`;\n        } else {\n            this.casterSelectionDisplay.textContent = `Caster: None Selected`;\n        }\n\n        if (this.targetSelectionState) {\n            this.targetSelectionDisplay.textContent = `Target: ${this.targetSelectionState.name}`;\n        } else {\n            this.targetSelectionDisplay.textContent = `Target: None Selected`;\n        }\n        this.APCount.textContent = `Action Points: ${turn.AP}`;\n    },\n\n    updateBotBar: function (selectedPC) {\n        if (selectedPC && !this.abilityListContainer.hasChildNodes()) {\n            selectedPC.abilities.forEach((element) => this.createAbility(element));\n        } else if (!selectedPC) {\n            this.abilityListContainer.innerHTML = ``;\n        }\n    },\n\n    createAbility: function (abilityIndex) {\n        const i = document.createElement(`div`);\n        i.className = `ability`;\n        i.innerHTML = `<div data-ability-index=${abilityIndex} class=\"abilityName\">${allAbilities[abilityIndex].name}</div>`;\n        this.abilityListContainer.append(i);\n    },\n\n    selectCaster: function (target) {\n        if (this.casterSelection !== null && target !== this.casterSelection) {\n            this.deselectCaster();\n        }\n        const targetGroupIndex = target.dataset.groupIndex;\n        this.casterSelectionState = PCs.charList[targetGroupIndex];\n        this.casterSelection = target;\n        if (this.casterSelectionState.hp === 0) {\n            this.casterSelection.style.borderColor = `rgb(75,75,150)`;\n        } else {\n            this.casterSelection.style.borderColor = `blue`;\n        }\n        this.updateBotBar();\n        this.updateEquipmentList();\n    },\n\n    deselectCaster: function () {\n        if (this.casterSelection) {\n            if (this.casterSelection === this.targetSelection) {\n                this.targetSelection.style.borderColor = `yellow`;\n                this.casterSelection = null;\n                this.casterSelectionState = null;\n            } else {\n                if (this.casterSelectionState.hp === 0) {\n                    this.casterSelection.style.borderColor = `rgb(50,50,50)`;\n                } else {\n                    this.casterSelection.style.borderColor = `white`;\n                }\n                this.casterSelection = null;\n                this.casterSelectionState = null;\n            }\n        }\n\n        // if(this.casterSelection) {\n        //    if(this.casterSelectionState.hp === 0) {\n        //         this.casterSelection.style.borderColor = `rgb(50,50,50)`;\n        //    } else {\n        //         this.casterSelection.style.borderColor = `white`;\n        //    }\n        //    this.casterSelection = null;\n        //    this.casterSelectionState = null;\n        // }\n        this.updateBotBar();\n        this.updateEquipmentList();\n    },\n\n    listenForCasterSelection: function () {\n        this.PCBar.addEventListener(`click`, (e) => {\n            if (e.target.className === `PC`) {\n                this.selectCaster(e.target);\n            } else {\n                this.deselectCaster();\n            }\n            this.updateTopBar();\n            this.updateBotBar(this.casterSelectionState);\n        })\n    },\n\n    listenForTargetSelection: function () {\n        this.midBar.addEventListener(`contextmenu`, (e) => {\n            e.preventDefault();\n            if (e.target.className === `PC` || e.target.className === `NPC`) {\n                this.selectTarget(e.target);\n            } else {\n                this.deselectTarget();\n            }\n            this.updateTopBar();\n        })\n    },\n\n    selectTarget: function (target) {\n        if (this.targetSelection !== null && target !== this.targetSelection) {\n            this.deselectTarget();\n        }\n        this.targetSelection = target;\n        let targetGroup = target.className;\n        const targetGroupIndex = target.dataset.groupIndex;\n        if (targetGroup === `NPC`) {\n            this.targetSelectionState = NPCs.charList[targetGroupIndex];\n            target.style.borderColor = `red`;\n        };\n        if (targetGroup === `PC`) {\n            this.targetSelectionState = PCs.charList[targetGroupIndex];\n            target.style.borderColor = `yellow`;\n        }\n    },\n\n    deselectTarget: function () {\n        if (this.targetSelection) {\n            if (this.targetSelection === this.casterSelection) {\n                if (this.targetSelectionState.hp === 0) {\n                    this.targetSelection.style.borderColor = `rgb(75,75,150)`;\n                } else {\n                    this.targetSelection.style.borderColor = `blue`;\n                }\n                this.targetSelection = null;\n                this.targetSelectionState = null;\n            } else {\n                if (this.targetSelectionState.hp === 0) {\n                    this.targetSelection.style.borderColor = `rgb(50,50,50)`;\n                } else {\n                    this.targetSelection.style.borderColor = `white`;\n                }\n                this.targetSelection = null;\n                this.targetSelectionState = null;\n            }\n        }\n    },\n\n    update: function () {\n        this.NPCBarRow3.innerHTML = ``;\n        this.NPCBarRow2.innerHTML = ``;\n        this.NPCBarRow1.innerHTML = ``;\n        this.PCBarRow1.innerHTML = ``;\n        this.PCBarRow2.innerHTML = ``;\n        this.PCBarRow3.innerHTML = ``;\n        for (let i = (PCs.charList.length - 1); i >= 0; i--) {\n            this.createChar(PCs.charList[i], i)\n        };\n        for (let i = (NPCs.charList.length - 1); i >= 0; i--) {\n            this.createChar(NPCs.charList[i], i)\n        };\n    },\n\n    updateEquipmentList: function () {\n        this.equipmentList.innerHTML = `Equipment:`;\n        if (this.casterSelectionState) {\n            for (let i = 0; i <= (Object.keys(this.casterSelectionState.equipment).length - 1); i++) {\n                this.createEquipmentDisplay(this.casterSelectionState, i)\n            };\n        }\n    },\n\n    createChar: function (char, charListIndex) {\n        const i = document.createElement(`div`);\n        i.className = `${char.groupName}`;\n        i.id = `index${charListIndex}`;\n        i.dataset.groupIndex = charListIndex;\n        forceHPtoZero(char);\n        if (char.hp === 0) {\n            i.style.borderColor = `rgb(50,50,50)`;\n            i.innerHTML = `<div class=\"name\">${char.name}</div>\n                           <div class=\"HP\">HP: ${char.hp} (Dead)</div>\n                           <div class=\"race\">Race: ${char.raceName}</div>\n                           <div class=\"talents\">Talents: ${char.talent1Name} & ${char.talent2Name}</div>`;\n        } else {\n            i.innerHTML = `<div class=\"name\">${char.name}</div>\n                           <div class=\"HP\">HP: ${char.hp}</div>\n                           <div class=\"race\">Race: ${char.raceName}</div>\n                           <div class=\"talents\">Talents: ${char.talent1Name} & ${char.talent2Name}</div>`;\n        }\n\n        switch (char.groupName) {\n            case `PC`:\n                if (this.casterSelectionState === char) {\n                    if (this.casterSelectionState.hp === 0) {\n                        i.style.borderColor = `rgb(75,75,150)`;\n                    } else {\n                        i.style.borderColor = `blue`;\n                    }\n                    this.casterSelection = i;\n                } else if (this.targetSelectionState === char) {\n                    i.style.borderColor = `yellow`;\n                    this.targetSelection = i;\n                }\n                this.appendPCCharToRow(char, i);\n                break;\n\n            case `NPC`:\n                if (this.targetSelectionState === char) {\n                    i.style.borderColor = `red`;\n                    this.targetSelection = i;\n                }\n                this.appendNPCCharToRow(char, i);\n                break;\n\n            case `Unassigned`:\n                console.log(`Error: Tried to put char with unassigned group onto DOM.`);\n                break;\n\n            default:\n                console.log(`Error: Something weird happened here.`);\n                break;\n        }\n    },\n\n    createEquipmentDisplay: function (char, keyNumberOfItem) {\n        const i = document.createElement(`div`);\n        const arrayOfAllKeysInEquipment = Object.keys(char.equipment);\n        const itemKeyName = arrayOfAllKeysInEquipment[keyNumberOfItem];\n        const item = char.equipment[itemKeyName];\n        if (item === null) {\n            i.innerHTML = `<div class=\"slotName\">${itemKeyName}: None</div>`;\n        } else if (item.damage) {\n            i.innerHTML = `<div class=\"slotName\">${itemKeyName}: ${item.name} Damage: ${item.damage[0][0]}D${item.damage[0][1]}</div>`;\n        } else {\n            i.innerHTML = `<div class=\"slotName\">${itemKeyName}: ${item.name} </div>`;\n        }\n        this.equipmentList.append(i);\n    },\n    appendPCCharToRow: function (char, i) {\n        switch (char.row) {\n            case 1: \n                this.PCBarRow1.append(i);\n            break;\n            case 2: \n                this.PCBarRow2.append(i);\n            break;\n            case 3: \n                this.PCBarRow3.append(i);\n            break;\n        }\n    },\n    appendNPCCharToRow: function (char, i) {\n        switch (char.row) {\n            case 1: \n                this.NPCBarRow1.append(i);\n            break;\n            case 2: \n                this.NPCBarRow2.append(i);\n            break;\n            case 3: \n                this.NPCBarRow3.append(i);\n            break;\n        }\n    },\n};\n\n/* #endregion DOM*/\n\ndefineAllAbilities();\ndefineAllWeapons();\ndefineAllRaces();\ndefineAllTalents();\ndefineAllArmors();\ndefineAllFeats();\ndefineAllBackgrounds();\n\ncharacterCreator(`Stroick`, allRaces[0], allTalents[0], allTalents[5], PCs);\ncharacterCreator(`Kliftin`, allRaces[1], allTalents[2], allTalents[6], PCs);\ncharacterCreator(`Dahmer Hobo`, allRaces[3], allTalents[6], allTalents[7], NPCs);\ncharacterCreator(`Evil`, allRaces[2], allTalents[4], allTalents[5], NPCs);\n\nconst stroick = PCs.charList[0];\nconst evil = NPCs.charList[1];\nconst kliftin = PCs.charList[1];\nconst hobo = NPCs.charList[0];\n\nDOM.update();\nDOM.listenForCasterSelection();\nDOM.listenForBotBar();\nDOM.listenForEndTurnButton();\nDOM.listenForTargetSelection();\nDOM.listenForMoveRowButtons();\n\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;